<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · AdaptiveResonance.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AdaptiveResonance.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AdaptiveResonance.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting-started/whatisart/">Background</a></li><li><a class="tocitem" href="../../getting-started/basic-example/">Basic Example</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../modules/">Modules</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../full-index/">Index</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/develop/docs/src/man/dev-index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="dev-main-index"><a class="docs-heading-anchor" href="#dev-main-index">Developer Index</a><a id="dev-main-index-1"></a><a class="docs-heading-anchor-permalink" href="#dev-main-index" title="Permalink"></a></h1><p>This page lists the types and functions that are internal to the <code>AdaptiveResonance.jl</code> package. Because they are not part of the public API, these names might change relatively frequently between versions and so should not be relied upon.</p><p>All internal names are listed in the <a href="#dev-index-methods">Index</a>, and each of these entries link to the docstrings in the <a href="#dev-index-docs">Docs</a> section.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>This section contains a list of internal names that link to their corresponding <a href="#dev-index-docs">Documentation</a>.</p><h3 id="dev-index-methods"><a class="docs-heading-anchor" href="#dev-index-methods">Methods</a><a id="dev-index-methods-1"></a><a class="docs-heading-anchor-permalink" href="#dev-index-methods" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.activation-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation</code></a></li><li><a href="#AdaptiveResonance.activation-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation</code></a></li><li><a href="#AdaptiveResonance.activation_match!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a></li><li><a href="#AdaptiveResonance.activation_match!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a></li><li><a href="#AdaptiveResonance.art_match-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a></li><li><a href="#AdaptiveResonance.art_match-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a></li><li><a href="#AdaptiveResonance.competition_kernel-Tuple{Integer, Integer}"><code>AdaptiveResonance.competition_kernel</code></a></li><li><a href="#AdaptiveResonance.create_category-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category</code></a></li><li><a href="#AdaptiveResonance.create_category-Tuple{DDVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category</code></a></li><li><a href="#AdaptiveResonance.ddt_x-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Bool}"><code>AdaptiveResonance.ddt_x</code></a></li><li><a href="#AdaptiveResonance.ddt_y-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Real, Bool}"><code>AdaptiveResonance.ddt_y</code></a></li><li><a href="#AdaptiveResonance.ddt_z-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.ddt_z</code></a></li><li><a href="#AdaptiveResonance.element_min-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.element_min</code></a></li><li><a href="#AdaptiveResonance.get_iterator-Tuple{ARTOpts, Integer}"><code>AdaptiveResonance.get_iterator</code></a></li><li><a href="#AdaptiveResonance.get_n_weights-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights</code></a></li><li><a href="#AdaptiveResonance.get_n_weights_vec-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights_vec</code></a></li><li><a href="#AdaptiveResonance.get_sample-Tuple{AbstractMatrix{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.get_sample</code></a></li><li><a href="#AdaptiveResonance.init_classify!-Tuple{AbstractArray{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_classify!</code></a></li><li><a href="#AdaptiveResonance.init_train!-Tuple{AbstractMatrix{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a></li><li><a href="#AdaptiveResonance.init_train!-Tuple{AbstractVector{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a></li><li><a href="#AdaptiveResonance.initialize!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.initialize!</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a></li><li><a href="#AdaptiveResonance.learn!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a></li><li><a href="#AdaptiveResonance.oriented_kernel-Tuple{Integer, Integer, Integer, Integer, Integer, Real, Real}"><code>AdaptiveResonance.oriented_kernel</code></a></li><li><a href="#AdaptiveResonance.set_threshold!-Tuple{ARTModule}"><code>AdaptiveResonance.set_threshold!</code></a></li><li><a href="#AdaptiveResonance.similarity-Tuple{AbstractString, FuzzyART, AbstractString, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.similarity</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{DAM}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{DDVFA}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{SFAM}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{DVFA}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{FuzzyART}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.surround_kernel-NTuple{5, Integer}"><code>AdaptiveResonance.surround_kernel</code></a></li><li><a href="#AdaptiveResonance.update_iter-Tuple{ARTModule, Union{ProgressBars.ProgressBar, UnitRange}, Integer}"><code>AdaptiveResonance.update_iter</code></a></li></ul><h3 id="dev-index-types"><a class="docs-heading-anchor" href="#dev-index-types">Types</a><a id="dev-index-types-1"></a><a class="docs-heading-anchor-permalink" href="#dev-index-types" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.ARTIterator"><code>AdaptiveResonance.ARTIterator</code></a></li></ul><h3 id="dev-index-types-2"><a class="docs-heading-anchor" href="#dev-index-types-2">Constants</a><a class="docs-heading-anchor-permalink" href="#dev-index-types-2" title="Permalink"></a></h3><ul></ul><h3 id="dev-index-docs"><a class="docs-heading-anchor" href="#dev-index-docs">Docs</a><a id="dev-index-docs-1"></a><a class="docs-heading-anchor-permalink" href="#dev-index-docs" title="Permalink"></a></h3><p>Documentation for all internal names are listed below.</p><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTIterator" href="#AdaptiveResonance.ARTIterator"><code>AdaptiveResonance.ARTIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ARTIterator</p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">const ARTIterator = Union{UnitRange, ProgressBar}</code></pre><p>Acceptable iterators for ART module training and inference</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.activation-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.activation-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activation(
    art::DAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Default ARTMAP&#39;s choice-by-difference activation function.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">activation(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/DAM.jl#L265"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/DAM.jl:265</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/DAM.jl#LL262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.activation-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.activation-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activation(
    art::SFAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the activation value of the Simple Fuzzy ARTMAP module with weight W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">activation(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/SFAM.jl#L281"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:281</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/SFAM.jl#LL277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.activation_match!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.activation_match!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activation_match!(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real
)
</code></pre><p><strong>Summary</strong></p><p>Compute and store the activation and match values for the DVFA module.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">activation_match!(art, x)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DVFA.jl#L325"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:325</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DVFA.jl#LL322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.activation_match!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.activation_match!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activation_match!(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real
)
</code></pre><p><strong>Summary</strong></p><p>Computes the activation and match functions of the art module against sample x.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to compute the activation and match values for all weights.</li><li><code>x::RealVector</code>: the sample to compute the activation and match functions against.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_FuzzyART = FuzzyART()
FuzzyART
    opts: opts_FuzzyART
    ...
julia&gt; x, y = load_data()
julia&gt; train!(my_FuzzyART, x)
julia&gt; x_sample = x[:, 1]
julia&gt; activation_match!(my_FuzzyART, x_sample)</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">activation_match!(art, x)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L390"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:390</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/FuzzyART.jl#LL371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.art_match-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.art_match-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">art_match(
    art::DAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the match function for the Default ARTMAP module with weight W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">art_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/DAM.jl#L284"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/DAM.jl:284</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/DAM.jl#LL281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.art_match-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.art_match-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">art_match(
    art::SFAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the match function for the Simple Fuzzy ARTMAP module with weight W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">art_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/SFAM.jl#L290"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:290</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/SFAM.jl#LL286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.competition_kernel-Tuple{Integer, Integer}" href="#AdaptiveResonance.competition_kernel-Tuple{Integer, Integer}"><code>AdaptiveResonance.competition_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">competition_kernel(l::Integer, k::Integer; sign) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Competition kernel for ARTSCENE: Stage 5.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">competition_kernel(l, k; sign)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/ARTSCENE.jl#L198"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:198</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/ARTSCENE.jl#LL195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.create_category-Tuple{DDVFA, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.create_category-Tuple{DDVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_category(
    art::DDVFA,
    sample::AbstractVector{T} where T&lt;:Real,
    label::Integer
) -&gt; Vector{FuzzyART}
</code></pre><p><strong>Summary</strong></p><p>Create a new category by appending and initializing a new FuzzyART node to F2.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module to create a new FuzzyART category in.</li><li><code>sample::RealVector</code>: the sample to use for instantiating the new category.</li><li><code>label::Integer</code>: the new label to use for the new category.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">create_category(art, sample, label)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DDVFA.jl#L359"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:359</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DDVFA.jl#LL351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.create_category-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.create_category-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_category(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real,
    y::Integer
) -&gt; Vector{Int64}
</code></pre><p><strong>Summary</strong></p><p>Creates a category for the FuzzyART module, expanding the weights and incrementing the category labels.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to add a category to.</li><li><code>x::RealVector</code>: the sample to use for adding a category.</li><li><code>y::Integer</code>: the new label for the new category.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">create_category(art, x, y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L360"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:360</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/FuzzyART.jl#LL352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ddt_x-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Bool}" href="#AdaptiveResonance.ddt_x-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Bool}"><code>AdaptiveResonance.ddt_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddt_x(
    x::AbstractArray{T} where T&lt;:Real,
    image::AbstractArray{T} where T&lt;:Real,
    sigma_s::AbstractArray{T} where T&lt;:Real,
    distributed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Time rate of change of LGN network (ARTSCENE Stage 2).</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">ddt_x(x, image, sigma_s, distributed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/ARTSCENE.jl#L38"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:38</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/ARTSCENE.jl#LL35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ddt_y-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Real, Bool}" href="#AdaptiveResonance.ddt_y-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Real, Bool}"><code>AdaptiveResonance.ddt_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddt_y(
    y::AbstractArray{T} where T&lt;:Real,
    X_plus::AbstractArray{T} where T&lt;:Real,
    X_minus::AbstractArray{T} where T&lt;:Real,
    alpha::Real,
    distributed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Shunting equation for ARTSCENE Stage 3.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">ddt_y(y, X_plus, X_minus, alpha, distributed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/ARTSCENE.jl#L114"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:114</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/ARTSCENE.jl#LL111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ddt_z-Tuple{AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.ddt_z-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.ddt_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddt_z(z::AbstractArray{T} where T&lt;:Real; distributed) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Time rate of change for ARTSCENE: Stage 5.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">ddt_z(z; distributed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/ARTSCENE.jl#L214"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:214</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/ARTSCENE.jl#LL211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.element_min-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.element_min-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.element_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element_min(
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the element-wise minimum between sample x and weight W.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealVector</code>: the input sample.</li><li><code>W::RealVector</code>: the weight vector to compare the sample against.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">element_min(x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L200"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:200</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_iterator-Tuple{ARTOpts, Integer}" href="#AdaptiveResonance.get_iterator-Tuple{ARTOpts, Integer}"><code>AdaptiveResonance.get_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_iterator(opts::ARTOpts, n_samples::Integer) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Creates an iterator object according to the ART/ARTMAP modules display settings for batch iteration.</p><p><strong>Arguments</strong></p><ul><li><code>opts::ARTOpts</code>: the ART/ARTMAP module&#39;s options containing display settings.</li><li><code>n_samples::Integer</code>: the number of iterations to create the iterator for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_iterator(opts, n_samples)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L419"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:419</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_n_weights-Tuple{DDVFA}" href="#AdaptiveResonance.get_n_weights-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_n_weights(art::DDVFA) -&gt; Int64
</code></pre><p><strong>Summary</strong></p><p>Convenience function; return the sum total number of weights in the DDVFA module.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_n_weights(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DDVFA.jl#L475"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:475</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DDVFA.jl#LL472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_n_weights_vec-Tuple{DDVFA}" href="#AdaptiveResonance.get_n_weights_vec-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_n_weights_vec(art::DDVFA) -&gt; Vector{Int64}
</code></pre><p><strong>Summary</strong></p><p>Convenience function; return the number of weights in each category as a vector.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module to get all of the weights from as a list.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_n_weights_vec(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DDVFA.jl#L468"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:468</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DDVFA.jl#LL462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_sample-Tuple{AbstractMatrix{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.get_sample-Tuple{AbstractMatrix{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.get_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_sample(
    x::AbstractMatrix{T} where T&lt;:Real,
    i::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns a sample from data array <code>x</code> at sample location <code>i</code>. This function implements the convention that columns are samples while rows are features within samples.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealMatrix</code>: the batch of data to grab a sample from.</li><li><code>i::Integer</code>: the index to get the sample from.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_sample(x, i)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L454"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:454</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.init_classify!-Tuple{AbstractArray{T} where T&lt;:Real, ARTModule, Bool}" href="#AdaptiveResonance.init_classify!-Tuple{AbstractArray{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_classify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_classify!(
    x::AbstractArray{T} where T&lt;:Real,
    art::ARTModule,
    preprocessed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Initializes the classification loop for batch inference.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealArray</code>: the data that is used for inference.</li><li><code>art::ARTModule</code>: the ART/ARTMAP module that will be used for inference.</li><li><code>preprocessed::Bool</code>: required flag for if the data has already been complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">init_classify!(x, art, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L519"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:519</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.init_train!-Tuple{AbstractMatrix{T} where T&lt;:Real, ARTModule, Bool}" href="#AdaptiveResonance.init_train!-Tuple{AbstractMatrix{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_train!(
    x::AbstractMatrix{T} where T&lt;:Real,
    art::ARTModule,
    preprocessed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Initializes the training loop for batch learning.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealMatrix</code>: the data that is used for training.</li><li><code>art::ARTModule</code>: the ART/ARTMAP that will be trained.</li><li><code>preprocessed::Bool</code>: required flag for if the data has already been complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">init_train!(x, art, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L501"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:501</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.init_train!-Tuple{AbstractVector{T} where T&lt;:Real, ARTModule, Bool}" href="#AdaptiveResonance.init_train!-Tuple{AbstractVector{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_train!(
    x::AbstractVector{T} where T&lt;:Real,
    art::ARTModule,
    preprocessed::Bool
) -&gt; AbstractVector{T} where T&lt;:Real
</code></pre><p><strong>Summary</strong></p><p>Initializes the module for training in a single iteration.</p><p>The purpose of this function is mainly to handle the conditions of complement coding. Fails if the module was incorrectly set up or if the module was not setup and the data was not preprocessed.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealVector</code>: the sample used for initialization.</li><li><code>art::ARTModule</code>: the ART/ARTMAP module that will be trained on the sample.</li><li><code>preprocessed::Bool</code>: a required flag for if the sample has already been complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">init_train!(x, art, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L470"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:470</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.initialize!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.initialize!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.initialize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize!(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real;
    y
) -&gt; Vector{Int64}
</code></pre><p><strong>Summary</strong></p><p>Initializes a FuzzyART learner with an intial sample &#39;x&#39;.</p><p>This function is used during the first training iteration when the FuzzyART module is empty.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to initialize.</li><li><code>x::RealVector</code>: the sample to use for initialization.</li><li><code>y::Integer=0</code>: the optional new label for the first weight of the FuzzyART module. If not specified, defaults the new label to 1.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_FuzzyART = FuzzyART()
FuzzyART
    opts: opts_FuzzyART
    ...
julia&gt; initialize!(my_FuzzyART, [1 2 3 4])</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">initialize!(art, x; y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L240"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:240</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/FuzzyART.jl#LL221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.learn!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn!(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real,
    index::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>In place learning function.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn!(art, x, index)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DVFA.jl#L346"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:346</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DVFA.jl#LL343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.learn!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn!(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real,
    index::Integer
) -&gt; Int64
</code></pre><p><strong>Summary</strong></p><p>In place learning function with instance counting.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to update.</li><li><code>x::RealVector</code>: the sample to learn from.</li><li><code>index::Integer</code>: the index of the FuzzyART weight to update.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn!(art, x, index)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L426"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:426</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/FuzzyART.jl#LL418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{DAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::DAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns a single updated weight for the Default ARTMAP module for weight vector W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/DAM.jl#L276"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/DAM.jl:276</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/DAM.jl#LL273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Return the modified weight of the DVFA module conditioned by sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DVFA.jl#L338"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:338</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DVFA.jl#LL335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Return the modified weight of the art module conditioned by sample x.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module containing learning options.</li><li><code>x::RealVector</code>: the sample to learn from.</li><li><code>W::RealVector</code>: the weight vector to update against the sample.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L413"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:413</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/FuzzyART.jl#LL405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::SFAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns a single updated weight for the Simple Fuzzy ARTMAP module for weight vector W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/SFAM.jl#L272"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:272</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/SFAM.jl#LL268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.oriented_kernel-Tuple{Integer, Integer, Integer, Integer, Integer, Real, Real}" href="#AdaptiveResonance.oriented_kernel-Tuple{Integer, Integer, Integer, Integer, Integer, Real, Real}"><code>AdaptiveResonance.oriented_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oriented_kernel(
    i::Integer,
    j::Integer,
    p::Integer,
    q::Integer,
    k::Integer,
    sigma_h::Real,
    sigma_v::Real;
    sign
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Oriented, elongated, spatially offset kernel G for ARTSCENE Stage 3.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">oriented_kernel(i, j, p, q, k, sigma_h, sigma_v; sign)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/ARTSCENE.jl#L92"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:92</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/ARTSCENE.jl#LL89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.set_threshold!-Tuple{ARTModule}" href="#AdaptiveResonance.set_threshold!-Tuple{ARTModule}"><code>AdaptiveResonance.set_threshold!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Sets the match threshold of the ART/ARTMAP module as a function of the vigilance parameter.</p><p>Depending on selected ART/ARTMAP module and its options, this may be a function of other parameters as well.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ART/ARTMAP module for setting a new threshold.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">set_threshold!(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DDVFA.jl#L219"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:219</code></a>.</p><pre><code class="language-julia hljs">set_threshold!(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DVFA.jl#L192"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:192</code></a>.</p><pre><code class="language-julia hljs">set_threshold!(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L213"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:213</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.similarity-Tuple{AbstractString, FuzzyART, AbstractString, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.similarity-Tuple{AbstractString, FuzzyART, AbstractString, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.similarity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similarity(
    method::AbstractString,
    F2::FuzzyART,
    field_name::AbstractString,
    sample::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Compute the similarity metric depending on method with explicit comparisons for the field name.</p><p><strong>Arguments</strong></p><ul><li><code>method::AbstractString</code>: the selected DDVFA linkage method.</li><li><code>F2::FuzzyART</code>: the FuzzyART module to compute the linkage method within.</li><li><code>field_name::AbstractString</code>: the activation or match value to compute, field_name ∈ [&quot;T&quot;, &quot;M&quot;]</li><li><code>sample::RealVector</code>: the sample to use for computing the linkage to the F2 module, sample ∈ DDVFA_METHODS.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">similarity(method, F2, field_name, sample)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DDVFA.jl#L389"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:389</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DDVFA.jl#LL380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{DAM}" href="#AdaptiveResonance.stopping_conditions-Tuple{DAM}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::DAM) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for Default ARTMAP, checked at the end of every epoch.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/DAM.jl#L257"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/DAM.jl:257</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/DAM.jl#LL254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{DDVFA}" href="#AdaptiveResonance.stopping_conditions-Tuple{DDVFA}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::DDVFA) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for Distributed Dual Vigilance Fuzzy ARTMAP.</p><p>Returns true if there is no change in weights during the epoch or the maxmimum epochs has been reached.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module for checking stopping conditions.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DDVFA.jl#L375"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:375</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DDVFA.jl#LL367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{DVFA}" href="#AdaptiveResonance.stopping_conditions-Tuple{DVFA}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::DVFA) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for a DVFA module.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/DVFA.jl#L354"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:354</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/DVFA.jl#LL351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{FuzzyART}" href="#AdaptiveResonance.stopping_conditions-Tuple{FuzzyART}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::FuzzyART) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for a FuzzyART module.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to check stopping conditions for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ART/FuzzyART.jl#L438"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:438</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ART/FuzzyART.jl#LL432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{SFAM}" href="#AdaptiveResonance.stopping_conditions-Tuple{SFAM}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::SFAM) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for Simple Fuzzy ARTMAP, checked at the end of every epoch.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/SFAM.jl#L263"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:263</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/SFAM.jl#LL260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.surround_kernel-NTuple{5, Integer}" href="#AdaptiveResonance.surround_kernel-NTuple{5, Integer}"><code>AdaptiveResonance.surround_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surround_kernel(
    i::Integer,
    j::Integer,
    p::Integer,
    q::Integer,
    scale::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Surround kernel S function for ARTSCENE Stage 2.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">surround_kernel(i, j, p, q, scale)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/ARTMAP/ARTSCENE.jl#L31"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:31</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/ARTMAP/ARTSCENE.jl#LL28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.update_iter-Tuple{ARTModule, Union{ProgressBars.ProgressBar, UnitRange}, Integer}" href="#AdaptiveResonance.update_iter-Tuple{ARTModule, Union{ProgressBars.ProgressBar, UnitRange}, Integer}"><code>AdaptiveResonance.update_iter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_iter(
    art::ARTModule,
    iter::Union{ProgressBars.ProgressBar, UnitRange},
    i::Integer
) -&gt; Union{Nothing, String}
</code></pre><p><strong>Summary</strong></p><p>Updates the iteration of the ART/ARTMAP module, training or inference, according to its display settings.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ART/ARTMAP module being iterated upon.</li><li><code>iter::ARTIterator</code>: the iterator object used in the training/inference loop.</li><li><code>i::Integer</code>: the iteration during training/inference that the iterator should be updated to.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">update_iter(art, iter, i)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/f31dd54b063723cc8ccb6ed0f078078465b0c518//src/common.jl#L437"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:437</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/f31dd54b063723cc8ccb6ed0f078078465b0c518/src/common.jl#LL429">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../full-index/">« Index</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 12 October 2022 21:25">Wednesday 12 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
