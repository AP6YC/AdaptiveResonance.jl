<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · AdaptiveResonance.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AdaptiveResonance.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AdaptiveResonance.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting-started/whatisart/">Background</a></li><li><a class="tocitem" href="../../getting-started/basic-example/">Basic Example</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../modules/">Modules</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../full-index/">Index</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/develop/docs/src/man/dev-index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="dev-main-index"><a class="docs-heading-anchor" href="#dev-main-index">Developer Index</a><a id="dev-main-index-1"></a><a class="docs-heading-anchor-permalink" href="#dev-main-index" title="Permalink"></a></h1><p>This page lists the types and functions that are internal to the <code>AdaptiveResonance.jl</code> package. Because they are not part of the public API, these names might change relatively frequently between versions and so should not be relied upon.</p><p>All internal names are listed in the <a href="#dev-index-methods">Index</a>, and each of these entries link to the docstrings in the <a href="#dev-index-docs">Docs</a> section.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>This section contains a list of internal names that link to their corresponding <a href="#dev-index-docs">Documentation</a>.</p><h3 id="dev-index-methods"><a class="docs-heading-anchor" href="#dev-index-methods">Methods</a><a id="dev-index-methods-1"></a><a class="docs-heading-anchor-permalink" href="#dev-index-methods" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.activation_match!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a></li><li><a href="#AdaptiveResonance.activation_match!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a></li><li><a href="#AdaptiveResonance.art_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_activation</code></a></li><li><a href="#AdaptiveResonance.art_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a></li><li><a href="#AdaptiveResonance.art_match-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a></li><li><a href="#AdaptiveResonance.average-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.average</code></a></li><li><a href="#AdaptiveResonance.basic_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.basic_activation</code></a></li><li><a href="#AdaptiveResonance.basic_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.basic_match</code></a></li><li><a href="#AdaptiveResonance.centroid-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Bool}"><code>AdaptiveResonance.centroid</code></a></li><li><a href="#AdaptiveResonance.choice_by_difference-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.choice_by_difference</code></a></li><li><a href="#AdaptiveResonance.color_to_gray-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>AdaptiveResonance.color_to_gray</code></a></li><li><a href="#AdaptiveResonance.competition_kernel-Tuple{Integer, Integer}"><code>AdaptiveResonance.competition_kernel</code></a></li><li><a href="#AdaptiveResonance.complete-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.complete</code></a></li><li><a href="#AdaptiveResonance.contrast_insensitive_oriented_filtering-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.contrast_insensitive_oriented_filtering</code></a></li><li><a href="#AdaptiveResonance.contrast_normalization-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.contrast_normalization</code></a></li><li><a href="#AdaptiveResonance.contrast_sensitive_oriented_filtering-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.contrast_sensitive_oriented_filtering</code></a></li><li><a href="#AdaptiveResonance.create_category!-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category!</code></a></li><li><a href="#AdaptiveResonance.create_category!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category!</code></a></li><li><a href="#AdaptiveResonance.create_category!-Tuple{DDVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category!</code></a></li><li><a href="#AdaptiveResonance.ddt_x-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.ddt_x</code></a></li><li><a href="#AdaptiveResonance.ddt_y-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Real}"><code>AdaptiveResonance.ddt_y</code></a></li><li><a href="#AdaptiveResonance.ddt_z-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.ddt_z</code></a></li><li><a href="#AdaptiveResonance.element_min-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.element_min</code></a></li><li><a href="#AdaptiveResonance.gamma_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.gamma_activation</code></a></li><li><a href="#AdaptiveResonance.gamma_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.gamma_match</code></a></li><li><a href="#AdaptiveResonance.get_data_shape-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_data_shape</code></a></li><li><a href="#AdaptiveResonance.get_dim-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_dim</code></a></li><li><a href="#AdaptiveResonance.get_iterator-Tuple{ARTOpts, Integer}"><code>AdaptiveResonance.get_iterator</code></a></li><li><a href="#AdaptiveResonance.get_n_samples-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_n_samples</code></a></li><li><a href="#AdaptiveResonance.get_n_weights-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights</code></a></li><li><a href="#AdaptiveResonance.get_n_weights_vec-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights_vec</code></a></li><li><a href="#AdaptiveResonance.get_sample-Tuple{AbstractMatrix{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.get_sample</code></a></li><li><a href="#AdaptiveResonance.init_classify!-Tuple{AbstractArray{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_classify!</code></a></li><li><a href="#AdaptiveResonance.init_train!-Tuple{AbstractMatrix{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a></li><li><a href="#AdaptiveResonance.init_train!-Tuple{AbstractVector{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a></li><li><a href="#AdaptiveResonance.initialize!-Tuple{ARTMAP, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.initialize!</code></a></li><li><a href="#AdaptiveResonance.initialize!-Tuple{ART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.initialize!</code></a></li><li><a href="#AdaptiveResonance.initialize!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.initialize!</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a></li><li><a href="#AdaptiveResonance.learn!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a></li><li><a href="#AdaptiveResonance.learn!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a></li><li><a href="#AdaptiveResonance.learn!-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a></li><li><a href="#AdaptiveResonance.median-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.median</code></a></li><li><a href="#AdaptiveResonance.orientation_competition-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.orientation_competition</code></a></li><li><a href="#AdaptiveResonance.oriented_kernel-Tuple{Integer, Integer, Integer, Integer, Integer, Real, Real}"><code>AdaptiveResonance.oriented_kernel</code></a></li><li><a href="#AdaptiveResonance.patch_orientation_color-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.patch_orientation_color</code></a></li><li><a href="#AdaptiveResonance.set_threshold!-Tuple{ARTModule}"><code>AdaptiveResonance.set_threshold!</code></a></li><li><a href="#AdaptiveResonance.similarity-Tuple{Symbol, FuzzyART, AbstractVector{T} where T&lt;:Real, Bool}"><code>AdaptiveResonance.similarity</code></a></li><li><a href="#AdaptiveResonance.single-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.single</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{DDVFA}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{SFAM}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{DVFA}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.stopping_conditions-Tuple{FuzzyART}"><code>AdaptiveResonance.stopping_conditions</code></a></li><li><a href="#AdaptiveResonance.surround_kernel-NTuple{5, Integer}"><code>AdaptiveResonance.surround_kernel</code></a></li><li><a href="#AdaptiveResonance.update_iter-Tuple{ARTModule, Union{ProgressBars.ProgressBar, UnitRange}, Integer}"><code>AdaptiveResonance.update_iter</code></a></li><li><a href="#AdaptiveResonance.weighted-Tuple{FuzzyART, Bool}"><code>AdaptiveResonance.weighted</code></a></li></ul><h3 id="dev-index-types"><a class="docs-heading-anchor" href="#dev-index-types">Types</a><a id="dev-index-types-1"></a><a class="docs-heading-anchor-permalink" href="#dev-index-types" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.ARTIterator"><code>AdaptiveResonance.ARTIterator</code></a></li><li><a href="#AdaptiveResonance.ARTMatrix"><code>AdaptiveResonance.ARTMatrix</code></a></li><li><a href="#AdaptiveResonance.ARTVector"><code>AdaptiveResonance.ARTVector</code></a></li></ul><h3 id="dev-index-types-2"><a class="docs-heading-anchor" href="#dev-index-types-2">Constants</a><a class="docs-heading-anchor-permalink" href="#dev-index-types-2" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.ACTIVATION_FUNCTIONS_DOCS"><code>AdaptiveResonance.ACTIVATION_FUNCTIONS_DOCS</code></a></li><li><a href="#AdaptiveResonance.ART_DIM"><code>AdaptiveResonance.ART_DIM</code></a></li><li><a href="#AdaptiveResonance.ART_SAMPLES"><code>AdaptiveResonance.ART_SAMPLES</code></a></li><li><a href="#AdaptiveResonance.ART_X_W_ARGS"><code>AdaptiveResonance.ART_X_W_ARGS</code></a></li><li><a href="#AdaptiveResonance.MATCH_FUNCTIONS_DOCS"><code>AdaptiveResonance.MATCH_FUNCTIONS_DOCS</code></a></li></ul><h3 id="dev-index-docs"><a class="docs-heading-anchor" href="#dev-index-docs">Docs</a><a id="dev-index-docs-1"></a><a class="docs-heading-anchor-permalink" href="#dev-index-docs" title="Permalink"></a></h3><p>Documentation for all internal names are listed below.</p><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ACTIVATION_FUNCTIONS_DOCS" href="#AdaptiveResonance.ACTIVATION_FUNCTIONS_DOCS"><code>AdaptiveResonance.ACTIVATION_FUNCTIONS_DOCS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ACTIVATION<em>FUNCTIONS</em>DOCS</p><p><strong>Description</strong></p><p>Common docstring for listing available activation functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTIterator" href="#AdaptiveResonance.ARTIterator"><code>AdaptiveResonance.ARTIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ARTIterator</p><p><strong>Description</strong></p><p>Acceptable iterators for ART module training and inference</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ART_DIM" href="#AdaptiveResonance.ART_DIM"><code>AdaptiveResonance.ART_DIM</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ART_DIM</p><p><strong>Description</strong></p><p>AdaptiveResonance.jl convention for which 2-D dimension contains the feature dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ART_SAMPLES" href="#AdaptiveResonance.ART_SAMPLES"><code>AdaptiveResonance.ART_SAMPLES</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ART_SAMPLES</p><p><strong>Description</strong></p><p>AdaptiveResonance.jl convention for which 2-D dimension contains the number of samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ART_X_W_ARGS" href="#AdaptiveResonance.ART_X_W_ARGS"><code>AdaptiveResonance.ART_X_W_ARGS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ART<em>X</em>W_ARGS</p><p><strong>Description</strong></p><p>Shared arguments string for methods using an ART module, sample &#39;x&#39;, and weight vector &#39;W&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.MATCH_FUNCTIONS_DOCS" href="#AdaptiveResonance.MATCH_FUNCTIONS_DOCS"><code>AdaptiveResonance.MATCH_FUNCTIONS_DOCS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>MATCH<em>FUNCTIONS</em>DOCS</p><p><strong>Description</strong></p><p>Common docstring for listing available match functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTMatrix" href="#AdaptiveResonance.ARTMatrix"><code>AdaptiveResonance.ARTMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ARTMatrix</p><p><strong>Description</strong></p><p>The type of matrix used by the AdaptiveResonance.jl package, used to configure matrix growth behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTVector" href="#AdaptiveResonance.ARTVector"><code>AdaptiveResonance.ARTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ARTVector</p><p><strong>Description</strong></p><p>The type of vector used by the AdaptiveResonance.jl package, used to configure vector growth behvior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.activation_match!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.activation_match!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activation_match!(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real
)
</code></pre><p><strong>Summary</strong></p><p>Compute and store the activation and match values for the DVFA module.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">activation_match!(art, x)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L360"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:360</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DVFA.jl#LL357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.activation_match!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.activation_match!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.activation_match!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">activation_match!(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real
)
</code></pre><p><strong>Summary</strong></p><p>Computes the activation and match functions of the art module against sample x.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to compute the activation and match values for all weights.</li><li><code>x::RealVector</code>: the sample to compute the activation and match functions against.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_FuzzyART = FuzzyART()
FuzzyART
    opts: opts_FuzzyART
    ...
julia&gt; x, y = load_data()
julia&gt; train!(my_FuzzyART, x)
julia&gt; x_sample = x[:, 1]
julia&gt; activation_match!(my_FuzzyART, x_sample)</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">activation_match!(art, x)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L389"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:389</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/FuzzyART.jl#LL370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.art_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.art_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_activation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">art_activation(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Evaluates the activation function of the ART/ARTMAP module on the sample &#39;x&#39; with weight &#39;W&#39;.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">art_activation(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L731"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:731</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL726-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.art_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.art_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">art_match(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Evaluates the match function of the ART/ARTMAP module on sample &#39;x&#39; with weight &#39;W&#39;.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">art_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L327"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:327</code></a>.</p><pre><code class="language-julia hljs">art_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L722"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:722</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL717-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.art_match-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.art_match-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.art_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">art_match(
    art::SFAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the match function for the Simple Fuzzy ARTMAP module with weight W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">art_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L327"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:327</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/SFAM.jl#LL323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.average-Tuple{AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.average-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.average</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average(field::AbstractVector{T} where T&lt;:Real) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Average linkage DDVFA similarity function.</p><p><strong>Arguments</strong></p><ul><li><code>field::RealVector</code>: the DDVFA FuzzyART F2 node field (F2.T or F2.M) to compute the linkage for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">average(field)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L476"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:476</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL471-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.basic_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.basic_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.basic_activation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basic_activation(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Simplified FuzzyARTMAP activation function.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">basic_activation(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L683"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:683</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL678-L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.basic_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.basic_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.basic_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basic_match(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Basic match function.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">basic_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L674"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:674</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL669-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.centroid-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Bool}" href="#AdaptiveResonance.centroid-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Bool}"><code>AdaptiveResonance.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(
    F2::FuzzyART,
    sample::AbstractVector{T} where T&lt;:Real,
    activation::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Centroid linkage DDVFA similarity function.</p><p><strong>Arguments:</strong></p><ul><li><p><code>F2::FuzzyART</code>: the DDVFA FuzzyART F2 node to compute the linkage method within.</p></li><li><p><code>sample::RealVector</code>: the sample to use for computing the linkage to the F2 module.</p></li><li><p><code>activation::Bool</code>: flag to use the activation function. False uses the match function.</p></li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">centroid(F2, sample, activation)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L523"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:523</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL515-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.choice_by_difference-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.choice_by_difference-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.choice_by_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">choice_by_difference(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Default ARTMAP&#39;s choice-by-difference activation function.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">choice_by_difference(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L710"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:710</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL705-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.color_to_gray-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat" href="#AdaptiveResonance.color_to_gray-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>AdaptiveResonance.color_to_gray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_to_gray(image::Array{T&lt;:AbstractFloat, 3}) -&gt; Matrix
</code></pre><p><strong>Summary</strong></p><p>ARTSCENE Stage 1: Color-to-gray image transformation.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">color_to_gray(image)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L23"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:23</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.competition_kernel-Tuple{Integer, Integer}" href="#AdaptiveResonance.competition_kernel-Tuple{Integer, Integer}"><code>AdaptiveResonance.competition_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">competition_kernel(l::Integer, k::Integer; sign) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Competition kernel for ARTSCENE: Stage 5.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">competition_kernel(l, k; sign)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L195"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:195</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.complete-Tuple{AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.complete-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.complete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complete(field::AbstractVector{T} where T&lt;:Real) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Complete linkage DDVFA similarity function.</p><p><strong>Arguments</strong></p><ul><li><code>field::RealVector</code>: the DDVFA FuzzyART F2 node field (F2.T or F2.M) to compute the linkage for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">complete(field)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L485"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:485</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL480-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.contrast_insensitive_oriented_filtering-Tuple{AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.contrast_insensitive_oriented_filtering-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.contrast_insensitive_oriented_filtering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contrast_insensitive_oriented_filtering(
    y::AbstractArray{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>ARTSCENE Stage 4: Contrast-insensitive oriented filtering.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">contrast_insensitive_oriented_filtering(y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L182"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:182</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.contrast_normalization-Tuple{AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.contrast_normalization-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.contrast_normalization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contrast_normalization(
    image::AbstractArray{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>ARTSCENE Stage 2: Constrast normalization.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">contrast_normalization(image)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L65"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:65</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.contrast_sensitive_oriented_filtering-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.contrast_sensitive_oriented_filtering-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.contrast_sensitive_oriented_filtering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contrast_sensitive_oriented_filtering(
    image::AbstractArray{T} where T&lt;:Real,
    x::AbstractArray{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>ARTSCENE Stage 3: Contrast-sensitive oriented filtering.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">contrast_sensitive_oriented_filtering(image, x)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L151"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:151</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.create_category!-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.create_category!-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Creates a category for the ARTModule module, expanding the weights and incrementing the category labels.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module to add a category to.</li><li><code>x::RealVector</code>: the sample to use for adding a category.</li><li><code>y::Integer</code>: the new label for the new category.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">create_category!(art, sample, label)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L380"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:380</code></a>.</p><pre><code class="language-julia hljs">create_category!(art, x, y; new_cluster)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L232"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:232</code></a>.</p><pre><code class="language-julia hljs">create_category!(art, x, y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L257"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:257</code></a>.</p><pre><code class="language-julia hljs">create_category!(art, x, y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L185"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:185</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.create_category!-Tuple{DDVFA, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.create_category!-Tuple{DDVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_category!(
    art::DDVFA,
    sample::AbstractVector{T} where T&lt;:Real,
    label::Integer
) -&gt; Vector{FuzzyART}
</code></pre><p><strong>Summary</strong></p><p>Create a new category by appending and initializing a new FuzzyART node to F2.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module to create a new FuzzyART category in.</li><li><code>sample::RealVector</code>: the sample to use for instantiating the new category.</li><li><code>label::Integer</code>: the new label to use for the new category.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">create_category!(art, sample, label)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L380"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:380</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.create_category!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.create_category!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.create_category!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_category!(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real,
    y::Integer;
    new_cluster
) -&gt; Vector{Int64}
</code></pre><p><strong>Summary</strong></p><p>Creates a new category for the DVFA modules.</p><p><strong>Arguments</strong></p><ul><li><code>art::DVFA</code>: the DVFA module to add a category to.</li><li><code>x::RealVector</code>: the sample to use for adding a category.</li><li><code>y::Integer</code>: the new label for the new category.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">create_category!(art, x, y; new_cluster)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L232"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:232</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DVFA.jl#LL224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ddt_x-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.ddt_x-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.ddt_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddt_x(
    x::AbstractArray{T} where T&lt;:Real,
    image::AbstractArray{T} where T&lt;:Real,
    sigma_s::AbstractArray{T} where T&lt;:Real
) -&gt; SharedArrays.SharedArray{Float64, 3}
</code></pre><p><strong>Summary</strong></p><p>Time rate of change of LGN network (ARTSCENE Stage 2).</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">ddt_x(x, image, sigma_s)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L39"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:39</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ddt_y-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Real}" href="#AdaptiveResonance.ddt_y-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real, Real}"><code>AdaptiveResonance.ddt_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddt_y(
    y::AbstractArray{T} where T&lt;:Real,
    X_plus::AbstractArray{T} where T&lt;:Real,
    X_minus::AbstractArray{T} where T&lt;:Real,
    alpha::Real
) -&gt; SharedArrays.SharedArray{Float64, 4}
</code></pre><p><strong>Summary</strong></p><p>Shunting equation for ARTSCENE Stage 3.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">ddt_y(y, X_plus, X_minus, alpha)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L112"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:112</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ddt_z-Tuple{AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.ddt_z-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.ddt_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ddt_z(
    z::AbstractArray{T} where T&lt;:Real
) -&gt; SharedArrays.SharedArray{Float64, 4}
</code></pre><p><strong>Summary</strong></p><p>Time rate of change for ARTSCENE: Stage 5.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">ddt_z(z)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L211"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:211</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.element_min-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.element_min-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.element_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element_min(
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the element-wise minimum between sample x and weight W.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealVector</code>: the input sample.</li><li><code>W::RealVector</code>: the weight vector to compare the sample against.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">element_min(x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L222"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:222</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.gamma_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.gamma_activation-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.gamma_activation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gamma_activation(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Gamma-normalized activation funtion.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">gamma_activation(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L701"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:701</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL696-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.gamma_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.gamma_match-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.gamma_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gamma_match(
    art::ARTModule,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Gamma-normalized match function.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ARTModule module.</li><li><code>x::RealVector</code>: the sample to use.</li><li><code>W::RealVector</code>: the weight vector to use.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">gamma_match(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L692"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:692</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL687-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_data_shape-Tuple{AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.get_data_shape-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_data_shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data_shape(
    data::AbstractMatrix{T} where T&lt;:Real
) -&gt; Tuple{Any, Any}
</code></pre><p><strong>Summary</strong></p><p>Returns the (dim, n_samples) of the provided 2-D data matrix, enforcing the ART package convention.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealMatrix</code>: the 2-D data to infer the feature dimension and number of samples from.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_data_shape(data)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L283"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:283</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_dim-Tuple{AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.get_dim-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dim(data::AbstractMatrix{T} where T&lt;:Real) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the dimension of the data, enforcint the (dim, n_samples) convention of the package.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealMatrix</code>: the 2-D data to infer the feature dimension of.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_dim(data)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L261"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:261</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_iterator-Tuple{ARTOpts, Integer}" href="#AdaptiveResonance.get_iterator-Tuple{ARTOpts, Integer}"><code>AdaptiveResonance.get_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_iterator(opts::ARTOpts, n_samples::Integer) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Creates an iterator object according to the ART/ARTMAP modules display settings for batch iteration.</p><p><strong>Arguments</strong></p><ul><li><code>opts::ARTOpts</code>: the ART/ARTMAP module&#39;s options containing display settings.</li><li><code>n_samples::Integer</code>: the number of iterations to create the iterator for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_iterator(opts, n_samples)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L443"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:443</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_n_samples-Tuple{AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.get_n_samples-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_n_samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_n_samples(data::AbstractMatrix{T} where T&lt;:Real) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns the number of samples, enforcing the convention of the package.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealMatrix</code>: the 2-D data to infer the number of samples from.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_n_samples(data)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L272"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:272</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_n_weights-Tuple{DDVFA}" href="#AdaptiveResonance.get_n_weights-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_n_weights(art::DDVFA) -&gt; Int64
</code></pre><p><strong>Summary</strong></p><p>Convenience function; return the sum total number of weights in the DDVFA module.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_n_weights(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L564"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:564</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_n_weights_vec-Tuple{DDVFA}" href="#AdaptiveResonance.get_n_weights_vec-Tuple{DDVFA}"><code>AdaptiveResonance.get_n_weights_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_n_weights_vec(art::DDVFA) -&gt; Vector{Int64}
</code></pre><p><strong>Summary</strong></p><p>Convenience function; return the number of weights in each category as a vector.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module to get all of the weights from as a list.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_n_weights_vec(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L557"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:557</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_sample-Tuple{AbstractMatrix{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.get_sample-Tuple{AbstractMatrix{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.get_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_sample(
    x::AbstractMatrix{T} where T&lt;:Real,
    i::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns a sample from data array <code>x</code> at sample location <code>i</code>. This function implements the convention that columns are samples while rows are features within samples.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealMatrix</code>: the batch of data to grab a sample from.</li><li><code>i::Integer</code>: the index to get the sample from.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_sample(x, i)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L478"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:478</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.init_classify!-Tuple{AbstractArray{T} where T&lt;:Real, ARTModule, Bool}" href="#AdaptiveResonance.init_classify!-Tuple{AbstractArray{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_classify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_classify!(
    x::AbstractArray{T} where T&lt;:Real,
    art::ARTModule,
    preprocessed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Initializes the classification loop for batch inference.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealArray</code>: the data that is used for inference.</li><li><code>art::ARTModule</code>: the ART/ARTMAP module that will be used for inference.</li><li><code>preprocessed::Bool</code>: required flag for if the data has already been complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">init_classify!(x, art, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L543"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:543</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.init_train!-Tuple{AbstractMatrix{T} where T&lt;:Real, ARTModule, Bool}" href="#AdaptiveResonance.init_train!-Tuple{AbstractMatrix{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_train!(
    x::AbstractMatrix{T} where T&lt;:Real,
    art::ARTModule,
    preprocessed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Initializes the training loop for batch learning.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealMatrix</code>: the data that is used for training.</li><li><code>art::ARTModule</code>: the ART/ARTMAP that will be trained.</li><li><code>preprocessed::Bool</code>: required flag for if the data has already been complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">init_train!(x, art, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L525"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:525</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.init_train!-Tuple{AbstractVector{T} where T&lt;:Real, ARTModule, Bool}" href="#AdaptiveResonance.init_train!-Tuple{AbstractVector{T} where T&lt;:Real, ARTModule, Bool}"><code>AdaptiveResonance.init_train!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_train!(
    x::AbstractVector{T} where T&lt;:Real,
    art::ARTModule,
    preprocessed::Bool
) -&gt; AbstractVector{T} where T&lt;:Real
</code></pre><p><strong>Summary</strong></p><p>Initializes the module for training in a single iteration.</p><p>The purpose of this function is mainly to handle the conditions of complement coding. Fails if the module was incorrectly set up or if the module was not setup and the data was not preprocessed.</p><p><strong>Arguments</strong></p><ul><li><code>x::RealVector</code>: the sample used for initialization.</li><li><code>art::ARTModule</code>: the ART/ARTMAP module that will be trained on the sample.</li><li><code>preprocessed::Bool</code>: a required flag for if the sample has already been complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">init_train!(x, art, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L494"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:494</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.initialize!-Tuple{ART, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.initialize!-Tuple{ART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.initialize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Initializes the ART module for training with sample &#39;x&#39; and optional label &#39;y&#39;, setting up the data configuration and instantiating the first category.</p><p>This function is used during the first training iteration when the ART module is empty.</p><p><strong>Arguments</strong></p><ul><li><code>art::ART</code>: the ART module to initialize.</li><li><code>x::RealVector</code>: the sample to use for initialization.</li><li><code>y::Integer=0</code>: the optional new label for the first weight of the ART module. If not specified, defaults the new label to 1.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_FuzzyART = FuzzyART()
FuzzyART
    opts: opts_FuzzyART
    ...
julia&gt; initialize!(my_FuzzyART, [1, 2, 3, 4])


# Method List / Definition Locations
</code></pre><p>julia initialize!(art, x; y)</p><pre><code class="nohighlight hljs">
defined at [`/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:213`](https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L213).
</code></pre><p>julia initialize!(art, x; y) ```</p><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L242"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:242</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/common.jl#LL77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.initialize!-Tuple{ARTMAP, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.initialize!-Tuple{ARTMAP, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.initialize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Initializes the supervised ARTMAP module for training with sample &#39;x&#39; and label &#39;y&#39;, setting up the data configuration and instantiating the first category.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTMAP</code>: the ARTMAP module to initialize.</li><li><code>x::RealVector</code>: the sample to use for initialization.</li><li><code>y::Integer</code>: the initial supervised label.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_sfam = SFAM()
SFAM
    opts: opts_SFAM
    ...
julia&gt; initialize!(my_SFAM, [1, 2, 3, 4])


# Method List / Definition Locations
</code></pre><p>julia initialize!(art, x, y) ```</p><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L177"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:177</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/common.jl#LL75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.initialize!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.initialize!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.initialize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize!(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real;
    y
) -&gt; Vector{Int64}
</code></pre><p><strong>Summary</strong></p><p>Initializes a DVFA learner with an initial sample &#39;x&#39;.</p><p>This function is used during the first training iteraction when the DVFA module is empty.</p><p><strong>Arguments</strong></p><ul><li><code>art::DVFA</code>: the DVFA module to initialize.</li><li><code>x::RealVector</code>: the sample to use for initialization.</li><li><code>y::Integer=0</code>: the optional new label for the first weight of the FuzzyART module. If not specified, defaults the new label to 1.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">initialize!(art, x; y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L213"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:213</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DVFA.jl#LL203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.learn!-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn!(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real,
    index::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>In place learning function.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn!(art, x, index)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L381"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:381</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DVFA.jl#LL378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.learn!-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn!(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real,
    index::Integer
) -&gt; Int64
</code></pre><p><strong>Summary</strong></p><p>In place learning function with instance counting.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to update.</li><li><code>x::RealVector</code>: the sample to learn from.</li><li><code>index::Integer</code>: the index of the FuzzyART weight to update.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn!(art, x, index)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L442"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:442</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/FuzzyART.jl#LL434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn!-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.learn!-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.learn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn!(
    art::SFAM,
    x::AbstractVector{T} where T&lt;:Real,
    index::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>In-place learning function.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn!(art, x, index)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L318"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:318</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/SFAM.jl#LL315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{DVFA, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::DVFA,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Return the modified weight of the DVFA module conditioned by sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L373"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:373</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DVFA.jl#LL370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{FuzzyART, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::FuzzyART,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Return the modified weight of the art module conditioned by sample x.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module containing learning options.</li><li><code>x::RealVector</code>: the sample to learn from.</li><li><code>W::RealVector</code>: the weight vector to update against the sample.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L429"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:429</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/FuzzyART.jl#LL421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.learn-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.learn-Tuple{SFAM, AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.learn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn(
    art::SFAM,
    x::AbstractVector{T} where T&lt;:Real,
    W::AbstractVector{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Returns a single updated weight for the Simple Fuzzy ARTMAP module for weight vector W and sample x.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">learn(art, x, W)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L310"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:310</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/SFAM.jl#LL306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.median-Tuple{AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.median-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(field::AbstractVector{T} where T&lt;:Real) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Median linkage DDVFA similarity function.</p><p><strong>Arguments</strong></p><ul><li><code>field::RealVector</code>: the DDVFA FuzzyART F2 node field (F2.T or F2.M) to compute the linkage for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">median(field)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L494"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:494</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL489-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.orientation_competition-Tuple{AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.orientation_competition-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.orientation_competition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orientation_competition(
    z::AbstractArray{T} where T&lt;:Real
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>ARTSCENE Stage 5: Orientation competition at the same position.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">orientation_competition(z)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L236"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:236</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.oriented_kernel-Tuple{Integer, Integer, Integer, Integer, Integer, Real, Real}" href="#AdaptiveResonance.oriented_kernel-Tuple{Integer, Integer, Integer, Integer, Integer, Real, Real}"><code>AdaptiveResonance.oriented_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oriented_kernel(
    i::Integer,
    j::Integer,
    p::Integer,
    q::Integer,
    k::Integer,
    sigma_h::Real,
    sigma_v::Real;
    sign
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Oriented, elongated, spatially offset kernel G for ARTSCENE Stage 3.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">oriented_kernel(i, j, p, q, k, sigma_h, sigma_v; sign)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L90"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:90</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.patch_orientation_color-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.patch_orientation_color-Tuple{AbstractArray{T} where T&lt;:Real, AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.patch_orientation_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">patch_orientation_color(
    z::AbstractArray{T} where T&lt;:Real,
    image::AbstractArray{T} where T&lt;:Real
) -&gt; Tuple{Union{Array{Float64, 4}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}}, Array{Float64, 3}}
</code></pre><p><strong>Summary</strong></p><p>ARTSCENE Stage 6: Create patch feature vectors.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">patch_orientation_color(z, image)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L257"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:257</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.set_threshold!-Tuple{ARTModule}" href="#AdaptiveResonance.set_threshold!-Tuple{ARTModule}"><code>AdaptiveResonance.set_threshold!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Sets the match threshold of the ART/ARTMAP module as a function of the vigilance parameter.</p><p>Depending on selected ART/ARTMAP module and its options, this may be a function of other parameters as well.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ART/ARTMAP module for setting a new threshold.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">set_threshold!(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L240"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:240</code></a>.</p><pre><code class="language-julia hljs">set_threshold!(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L197"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:197</code></a>.</p><pre><code class="language-julia hljs">set_threshold!(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L233"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:233</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.similarity-Tuple{Symbol, FuzzyART, AbstractVector{T} where T&lt;:Real, Bool}" href="#AdaptiveResonance.similarity-Tuple{Symbol, FuzzyART, AbstractVector{T} where T&lt;:Real, Bool}"><code>AdaptiveResonance.similarity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similarity(
    method::Symbol,
    F2::FuzzyART,
    sample::AbstractVector{T} where T&lt;:Real,
    activation::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Compute the similarity metric depending on method with explicit comparisons for the field name.</p><p><strong>Arguments</strong></p><ul><li><p><code>method::Symbol</code>: the linkage method to use.</p></li><li><p><code>F2::FuzzyART</code>: the DDVFA FuzzyART F2 node to compute the linkage method within.</p></li><li><p><code>sample::RealVector</code>: the sample to use for computing the linkage to the F2 module.</p></li><li><p><code>activation::Bool</code>: flag to use the activation function. False uses the match function.</p></li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">similarity(method, F2, sample, activation)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L435"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:435</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.single-Tuple{AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.single-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.single</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">single(field::AbstractVector{T} where T&lt;:Real) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Single linkage DDVFA similarity function.</p><p><strong>Arguments</strong></p><ul><li><code>field::RealVector</code>: the DDVFA FuzzyART F2 node field (F2.T or F2.M) to compute the linkage for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">single(field)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L467"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:467</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL462-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{DDVFA}" href="#AdaptiveResonance.stopping_conditions-Tuple{DDVFA}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::DDVFA) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for Distributed Dual Vigilance Fuzzy ARTMAP.</p><p>Returns true if there is no change in weights during the epoch or the maxmimum epochs has been reached.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module for checking stopping conditions.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L396"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:396</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{DVFA}" href="#AdaptiveResonance.stopping_conditions-Tuple{DVFA}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::DVFA) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for a DVFA module.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DVFA.jl#L389"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:389</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DVFA.jl#LL386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{FuzzyART}" href="#AdaptiveResonance.stopping_conditions-Tuple{FuzzyART}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::FuzzyART) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for a FuzzyART module.</p><p><strong>Arguments</strong></p><ul><li><code>art::FuzzyART</code>: the FuzzyART module to check stopping conditions for.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/FuzzyART.jl#L454"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:454</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/FuzzyART.jl#LL448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.stopping_conditions-Tuple{SFAM}" href="#AdaptiveResonance.stopping_conditions-Tuple{SFAM}"><code>AdaptiveResonance.stopping_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stopping_conditions(art::SFAM) -&gt; Bool
</code></pre><p><strong>Summary</strong></p><p>Stopping conditions for Simple Fuzzy ARTMAP, checked at the end of every epoch.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">stopping_conditions(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/SFAM.jl#L301"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:301</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/SFAM.jl#LL298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.surround_kernel-NTuple{5, Integer}" href="#AdaptiveResonance.surround_kernel-NTuple{5, Integer}"><code>AdaptiveResonance.surround_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surround_kernel(
    i::Integer,
    j::Integer,
    p::Integer,
    q::Integer,
    scale::Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Surround kernel S function for ARTSCENE Stage 2.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">surround_kernel(i, j, p, q, scale)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ARTMAP/ARTSCENE.jl#L32"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ARTMAP/ARTSCENE.jl#LL29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.update_iter-Tuple{ARTModule, Union{ProgressBars.ProgressBar, UnitRange}, Integer}" href="#AdaptiveResonance.update_iter-Tuple{ARTModule, Union{ProgressBars.ProgressBar, UnitRange}, Integer}"><code>AdaptiveResonance.update_iter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_iter(
    art::ARTModule,
    iter::Union{ProgressBars.ProgressBar, UnitRange},
    i::Integer
) -&gt; Union{Nothing, String}
</code></pre><p><strong>Summary</strong></p><p>Updates the iteration of the ART/ARTMAP module, training or inference, according to its display settings.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ART/ARTMAP module being iterated upon.</li><li><code>iter::ARTIterator</code>: the iterator object used in the training/inference loop.</li><li><code>i::Integer</code>: the iteration during training/inference that the iterator should be updated to.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">update_iter(art, iter, i)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/common.jl#L461"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:461</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/common.jl#LL453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.weighted-Tuple{FuzzyART, Bool}" href="#AdaptiveResonance.weighted-Tuple{FuzzyART, Bool}"><code>AdaptiveResonance.weighted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighted(F2::FuzzyART, activation::Bool) -&gt; Float64
</code></pre><p><strong>Summary</strong></p><p>Weighted linkage DDVFA similarity function.</p><p><strong>Arguments:</strong></p><ul><li><p><code>F2::FuzzyART</code>: the DDVFA FuzzyART F2 node to compute the linkage method within.</p></li><li><p><code>activation::Bool</code>: flag to use the activation function. False uses the match function.</p></li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">weighted(F2, activation)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/d0a55ab955914bd72b9f7e35a74af858cbae2f7f//src/ART/DDVFA.jl#L505"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:505</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/d0a55ab955914bd72b9f7e35a74af858cbae2f7f/src/ART/DDVFA.jl#LL498-L501">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../full-index/">« Index</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 16 December 2022 03:25">Friday 16 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
