<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · AdaptiveResonance.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AdaptiveResonance.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AdaptiveResonance.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting-started/whatisart/">Background</a></li><li><a class="tocitem" href="../../getting-started/basic-example/">Basic Example</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../modules/">Modules</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#index-docs"><span>Docs</span></a></li></ul></li><li><a class="tocitem" href="../dev-index/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/develop/docs/src/man/full-index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="main-index"><a class="docs-heading-anchor" href="#main-index">Index</a><a id="main-index-1"></a><a class="docs-heading-anchor-permalink" href="#main-index" title="Permalink"></a></h1><p>This page lists the core methods and types of the <code>AdaptiveResonance.jl</code> package. The <a href="#index-modules">Modules</a> section lists the modules exported by the package including the <code>AdaptiveResonance</code> module itself. The <a href="#index-methods">Methods</a> section lists the public methods for the package that use the modules in <a href="#index-types">Types</a>. Each of these entries link to the docstrings in the <a href="#index-docs">Docs</a> section.</p><p>ART modules document their internal working parameters and references, while their hyperparameters/options are documented under their corresponding option structs <code>opts_...</code>.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>This section enumerates the names exported by the package, each of which links to its corresponding <a href="#index-docs">Documentation</a>.</p><h3 id="index-modules"><a class="docs-heading-anchor" href="#index-modules">Modules</a><a id="index-modules-1"></a><a class="docs-heading-anchor-permalink" href="#index-modules" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.AdaptiveResonance"><code>AdaptiveResonance.AdaptiveResonance</code></a></li></ul><h3 id="index-methods"><a class="docs-heading-anchor" href="#index-methods">Methods</a><a id="index-methods-1"></a><a class="docs-heading-anchor-permalink" href="#index-methods" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.DAM-Tuple{}"><code>AdaptiveResonance.DAM</code></a></li><li><a href="#AdaptiveResonance.DAM-Tuple{opts_SFAM}"><code>AdaptiveResonance.DAM</code></a></li><li><a href="#AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{opts_FuzzyART}"><code>AdaptiveResonance.GammaNormalizedFuzzyART</code></a></li><li><a href="#AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{}"><code>AdaptiveResonance.GammaNormalizedFuzzyART</code></a></li><li><a href="#AdaptiveResonance.artscene_filter-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>AdaptiveResonance.artscene_filter</code></a></li><li><a href="#AdaptiveResonance.classify-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.classify</code></a></li><li><a href="#AdaptiveResonance.classify-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.classify</code></a></li><li><a href="#AdaptiveResonance.complement_code-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.complement_code</code></a></li><li><a href="#AdaptiveResonance.data_setup!-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.data_setup!</code></a></li><li><a href="#AdaptiveResonance.data_setup!-Tuple{DataConfig, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.data_setup!</code></a></li><li><a href="#AdaptiveResonance.get_W-Tuple{DDVFA}"><code>AdaptiveResonance.get_W</code></a></li><li><a href="#AdaptiveResonance.get_data_characteristics-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_data_characteristics</code></a></li><li><a href="#AdaptiveResonance.linear_normalization-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.linear_normalization</code></a></li><li><a href="#AdaptiveResonance.linear_normalization-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.linear_normalization</code></a></li><li><a href="#AdaptiveResonance.opts_DAM-Tuple{}"><code>AdaptiveResonance.opts_DAM</code></a></li><li><a href="#AdaptiveResonance.opts_GammaNormalizedFuzzyART-Tuple{}"><code>AdaptiveResonance.opts_GammaNormalizedFuzzyART</code></a></li><li><a href="#AdaptiveResonance.performance-Tuple{AbstractVector{T} where T&lt;:Integer, AbstractVector{T} where T&lt;:Integer}"><code>AdaptiveResonance.performance</code></a></li><li><a href="#AdaptiveResonance.train!-Tuple{ART, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.train!</code></a></li><li><a href="#AdaptiveResonance.train!-Tuple{ART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.train!</code></a></li><li><a href="#AdaptiveResonance.train!"><code>AdaptiveResonance.train!</code></a></li><li><a href="#AdaptiveResonance.train!-Tuple{ARTMAP, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.train!</code></a></li></ul><h3 id="index-types"><a class="docs-heading-anchor" href="#index-types">Types</a><a id="index-types-1"></a><a class="docs-heading-anchor-permalink" href="#index-types" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.ART"><code>AdaptiveResonance.ART</code></a></li><li><a href="#AdaptiveResonance.ARTMAP"><code>AdaptiveResonance.ARTMAP</code></a></li><li><a href="#AdaptiveResonance.ARTModule"><code>AdaptiveResonance.ARTModule</code></a></li><li><a href="#AdaptiveResonance.ARTOpts"><code>AdaptiveResonance.ARTOpts</code></a></li><li><a href="#AdaptiveResonance.DDVFA-Tuple{}"><code>AdaptiveResonance.DDVFA</code></a></li><li><a href="#AdaptiveResonance.DDVFA"><code>AdaptiveResonance.DDVFA</code></a></li><li><a href="#AdaptiveResonance.DDVFA-Tuple{opts_DDVFA}"><code>AdaptiveResonance.DDVFA</code></a></li><li><a href="#AdaptiveResonance.DVFA-Tuple{opts_DVFA}"><code>AdaptiveResonance.DVFA</code></a></li><li><a href="#AdaptiveResonance.DVFA"><code>AdaptiveResonance.DVFA</code></a></li><li><a href="#AdaptiveResonance.DVFA-Tuple{}"><code>AdaptiveResonance.DVFA</code></a></li><li><a href="#AdaptiveResonance.DataConfig"><code>AdaptiveResonance.DataConfig</code></a></li><li><a href="#AdaptiveResonance.DataConfig-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.DataConfig</code></a></li><li><a href="#AdaptiveResonance.DataConfig-Tuple{}"><code>AdaptiveResonance.DataConfig</code></a></li><li><a href="#AdaptiveResonance.DataConfig-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.DataConfig</code></a></li><li><a href="#AdaptiveResonance.DataConfig-Tuple{Real, Real, Integer}"><code>AdaptiveResonance.DataConfig</code></a></li><li><a href="#AdaptiveResonance.FAM-Tuple{}"><code>AdaptiveResonance.FAM</code></a></li><li><a href="#AdaptiveResonance.FAM"><code>AdaptiveResonance.FAM</code></a></li><li><a href="#AdaptiveResonance.FAM-Tuple{opts_FAM}"><code>AdaptiveResonance.FAM</code></a></li><li><a href="#AdaptiveResonance.FuzzyART-Tuple{opts_FuzzyART}"><code>AdaptiveResonance.FuzzyART</code></a></li><li><a href="#AdaptiveResonance.FuzzyART-Tuple{opts_FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.FuzzyART</code></a></li><li><a href="#AdaptiveResonance.FuzzyART-Tuple{}"><code>AdaptiveResonance.FuzzyART</code></a></li><li><a href="#AdaptiveResonance.FuzzyART"><code>AdaptiveResonance.FuzzyART</code></a></li><li><a href="#AdaptiveResonance.SFAM-Tuple{opts_SFAM}"><code>AdaptiveResonance.SFAM</code></a></li><li><a href="#AdaptiveResonance.SFAM-Tuple{}"><code>AdaptiveResonance.SFAM</code></a></li><li><a href="#AdaptiveResonance.SFAM"><code>AdaptiveResonance.SFAM</code></a></li><li><a href="#AdaptiveResonance.opts_DDVFA"><code>AdaptiveResonance.opts_DDVFA</code></a></li><li><a href="#AdaptiveResonance.opts_DVFA"><code>AdaptiveResonance.opts_DVFA</code></a></li><li><a href="#AdaptiveResonance.opts_FAM"><code>AdaptiveResonance.opts_FAM</code></a></li><li><a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a></li><li><a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a></li></ul><h3 id="index-constants"><a class="docs-heading-anchor" href="#index-constants">Constants</a><a id="index-constants-1"></a><a class="docs-heading-anchor-permalink" href="#index-constants" title="Permalink"></a></h3><ul><li><a href="#AdaptiveResonance.ACTIVATION_FUNCTIONS"><code>AdaptiveResonance.ACTIVATION_FUNCTIONS</code></a></li><li><a href="#AdaptiveResonance.ADAPTIVERESONANCE_MODULES"><code>AdaptiveResonance.ADAPTIVERESONANCE_MODULES</code></a></li><li><a href="#AdaptiveResonance.ADAPTIVERESONANCE_VERSION"><code>AdaptiveResonance.ADAPTIVERESONANCE_VERSION</code></a></li><li><a href="#AdaptiveResonance.ARTMAP_MODULES"><code>AdaptiveResonance.ARTMAP_MODULES</code></a></li><li><a href="#AdaptiveResonance.ART_MODULES"><code>AdaptiveResonance.ART_MODULES</code></a></li><li><a href="#AdaptiveResonance.DDVFA_METHODS"><code>AdaptiveResonance.DDVFA_METHODS</code></a></li><li><a href="#AdaptiveResonance.MATCH_FUNCTIONS"><code>AdaptiveResonance.MATCH_FUNCTIONS</code></a></li></ul><h2 id="index-docs"><a class="docs-heading-anchor" href="#index-docs">Docs</a><a id="index-docs-1"></a><a class="docs-heading-anchor-permalink" href="#index-docs" title="Permalink"></a></h2><p>This section lists the documentation for every exported name of the <code>AdaptiveResonance.jl</code> package.</p><h3 id="index-modules-docs"><a class="docs-heading-anchor" href="#index-modules-docs">Modules</a><a id="index-modules-docs-1"></a><a class="docs-heading-anchor-permalink" href="#index-modules-docs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.AdaptiveResonance" href="#AdaptiveResonance.AdaptiveResonance"><code>AdaptiveResonance.AdaptiveResonance</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Main module for <code>AdaptiveResonance.jl</code>, a Julia package of adaptive resonance theory algorithms.</p><p>This module exports all of the ART modules, options, and utilities used by the <code>AdaptiveResonance.jl package.</code> For full usage, see the official guide at https://ap6yc.github.io/AdaptiveResonance.jl/dev/man/guide/.</p><p><strong>Basic Usage</strong></p><p>Install and import the package in a script with</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;AdaptiveResonance&quot;)
using AdaptiveResonance</code></pre><p>then create an ART module with default options</p><pre><code class="language-julia hljs">my_art = DDVFA()</code></pre><p>or custom options via keyword arguments</p><pre><code class="language-julia hljs">my_art = DDVFA(rho_ub=0.45, rho_ub=0.7)</code></pre><p>Train all models with <code>train!</code> and conduct inference with <code>classify</code>. In batch, samples are interpreted in the Julia column-major fashion with dimensions <code>(n_dim, n_samples)</code> (i.e., columns are samples).</p><p>Train unsupervised ART modules incrementally or in batch with optional labels as a keyword argument <code>y</code></p><pre><code class="language-julia hljs"># Load your data somehow
samples, labels = load_some_data()

# Unsupervised batch
train!(my_art, samples)

# Supervised batch
train!(my_art, samples, y=labels)

# Unsupervised incremental
for ix in eachindex(labels)
    train!(my_art, samples[:, ix])
end

# Supervised incremental
for ix in eachindex(labels)
    train!(my_art, samples[:, ix], y=labels[ix])
end</code></pre><p>Train supervised ARTMAP with positional arguments</p><pre><code class="language-julia hljs">my_artmap = SFAM()
train!(my_artmap, samples, labels)</code></pre><p>With either module, conduct inference with <code>classify(art, samples)</code></p><pre><code class="language-julia hljs"># Batch inference
y_hat = classify(my_art, test_samples)

# Incremental inference
for ix in eachindex(test_labels)
    y_hat[ix] = classify(my_artmap, test_samples[:, ix])
end</code></pre><p><strong>Imports</strong></p><p>The following names are imported by the package as dependencies:</p><ul><li><code>Base</code></li><li><code>Core</code></li><li><code>Distributed</code></li><li><code>DocStringExtensions</code></li><li><code>ElasticArrays</code></li><li><code>Logging</code></li><li><code>NumericalTypeAliases</code></li><li><code>Parameters</code></li><li><code>Pkg</code></li><li><code>ProgressBars</code></li><li><code>SharedArrays</code></li></ul><p><strong>Exports</strong></p><p>The following names are exported and available when <code>using</code> the package:</p><ul><li><a href="#AdaptiveResonance.ACTIVATION_FUNCTIONS"><code>ACTIVATION_FUNCTIONS</code></a></li><li><a href="#AdaptiveResonance.ADAPTIVERESONANCE_MODULES"><code>ADAPTIVERESONANCE_MODULES</code></a></li><li><a href="#AdaptiveResonance.ADAPTIVERESONANCE_VERSION"><code>ADAPTIVERESONANCE_VERSION</code></a></li><li><a href="#AdaptiveResonance.ART"><code>ART</code></a></li><li><a href="#AdaptiveResonance.ARTMAP"><code>ARTMAP</code></a></li><li><a href="#AdaptiveResonance.ARTMAP_MODULES"><code>ARTMAP_MODULES</code></a></li><li><a href="#AdaptiveResonance.ARTModule"><code>ARTModule</code></a></li><li><a href="#AdaptiveResonance.ARTOpts"><code>ARTOpts</code></a></li><li><a href="#AdaptiveResonance.ART_MODULES"><code>ART_MODULES</code></a></li><li><a href="#AdaptiveResonance.DAM-Tuple{opts_SFAM}"><code>DAM</code></a></li><li><a href="#AdaptiveResonance.DDVFA"><code>DDVFA</code></a></li><li><a href="#AdaptiveResonance.DDVFA_METHODS"><code>DDVFA_METHODS</code></a></li><li><a href="#AdaptiveResonance.DVFA"><code>DVFA</code></a></li><li><a href="#AdaptiveResonance.DataConfig"><code>DataConfig</code></a></li><li><a href="#AdaptiveResonance.FAM"><code>FAM</code></a></li><li><a href="#AdaptiveResonance.FuzzyART"><code>FuzzyART</code></a></li><li><a href="#AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{opts_FuzzyART}"><code>GammaNormalizedFuzzyART</code></a></li><li><a href="#AdaptiveResonance.MATCH_FUNCTIONS"><code>MATCH_FUNCTIONS</code></a></li><li><a href="#AdaptiveResonance.SFAM"><code>SFAM</code></a></li><li><a href="#AdaptiveResonance.artscene_filter-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>artscene_filter</code></a></li><li><a href="#AdaptiveResonance.classify-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}"><code>classify</code></a></li><li><a href="#AdaptiveResonance.complement_code-Tuple{AbstractArray{T} where T&lt;:Real}"><code>complement_code</code></a></li><li><a href="#AdaptiveResonance.data_setup!-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}"><code>data_setup!</code></a></li><li><a href="#AdaptiveResonance.get_W-Tuple{DDVFA}"><code>get_W</code></a></li><li><a href="#AdaptiveResonance.get_data_characteristics-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>get_data_characteristics</code></a></li><li><a href="#AdaptiveResonance.linear_normalization-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>linear_normalization</code></a></li><li><a href="#AdaptiveResonance.opts_DAM-Tuple{}"><code>opts_DAM</code></a></li><li><a href="#AdaptiveResonance.opts_DDVFA"><code>opts_DDVFA</code></a></li><li><a href="#AdaptiveResonance.opts_DVFA"><code>opts_DVFA</code></a></li><li><a href="#AdaptiveResonance.opts_FAM"><code>opts_FAM</code></a></li><li><a href="#AdaptiveResonance.opts_FuzzyART"><code>opts_FuzzyART</code></a></li><li><a href="#AdaptiveResonance.opts_GammaNormalizedFuzzyART-Tuple{}"><code>opts_GammaNormalizedFuzzyART</code></a></li><li><a href="#AdaptiveResonance.opts_SFAM"><code>opts_SFAM</code></a></li><li><a href="#AdaptiveResonance.performance-Tuple{AbstractVector{T} where T&lt;:Integer, AbstractVector{T} where T&lt;:Integer}"><code>performance</code></a></li><li><a href="#AdaptiveResonance.train!"><code>train!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/AdaptiveResonance.jl#LL1-L83">source</a></section></article><h3 id="index-functions-docs"><a class="docs-heading-anchor" href="#index-functions-docs">Functions</a><a id="index-functions-docs-1"></a><a class="docs-heading-anchor-permalink" href="#index-functions-docs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DAM-Tuple{opts_SFAM}" href="#AdaptiveResonance.DAM-Tuple{opts_SFAM}"><code>AdaptiveResonance.DAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DAM(opts::opts_SFAM) -&gt; SFAM
</code></pre><p><strong>Summary</strong></p><p>Implements a Default ARTMAP module with specified options.</p><p>Default ARTMAP is a variant of SFAM, using the <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a> options. This constructor sets the activation to <code>:choice_by_difference</code> in addition to the keyword argument options you provide.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_SFAM</code>: the Simplified FuzzyARTMAP options (see <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a>).</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DAM(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/variants.jl#L41"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/variants.jl:41</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/variants.jl#LL33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DAM-Tuple{}" href="#AdaptiveResonance.DAM-Tuple{}"><code>AdaptiveResonance.DAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DAM(; kwargs...) -&gt; SFAM
</code></pre><p><strong>Summary</strong></p><p>Constructs a Default ARTMAP module using a SFAM module using Default ARTMAP&#39;s choice-by-difference activation function.</p><p>Default ARTMAP is a variant of SFAM, using the <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a> options. This constructor sets the activation to <code>:choice_by_difference</code> in addition to the keyword argument options you provide.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs</code>: keyword arguments of Simplified FuzzyARTMAP options (see <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a>)</li></ul><p><strong>References:</strong></p><ol><li>G. P. Amis and G. A. Carpenter, &#39;Default ARTMAP 2,&#39; IEEE Int. Conf. Neural Networks - Conf. Proc., vol. 2, no. September 2007, pp. 777-782, Mar. 2007, doi: 10.1109/IJCNN.2007.4371056.</li></ol><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DAM(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/variants.jl#L29"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/variants.jl:29</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/variants.jl#LL18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{opts_FuzzyART}" href="#AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{opts_FuzzyART}"><code>AdaptiveResonance.GammaNormalizedFuzzyART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GammaNormalizedFuzzyART(opts::opts_FuzzyART)
</code></pre><p><strong>Summary</strong></p><p>Implements a Gamma-Normalized FuzzyART module with specified options.</p><p>GammaNormalizedFuzzyART is a variant of FuzzyART, using the <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a> options. This constructor passes <code>gamma_normalization=true</code>, which internally uses <code>match=:gamma_match</code> and <code>activation=:gamma_activation</code> in addition to the keyword argument options you provide.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_FuzzyART</code>: the Fuzzy ART options (see <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a>).</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">GammaNormalizedFuzzyART(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/variants.jl#L39"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/variants.jl:39</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/variants.jl#LL31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{}" href="#AdaptiveResonance.GammaNormalizedFuzzyART-Tuple{}"><code>AdaptiveResonance.GammaNormalizedFuzzyART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GammaNormalizedFuzzyART(; kwargs...) -&gt; FuzzyART
</code></pre><p><strong>Summary</strong></p><p>Constructs a Gamma-Normalized FuzzyART module as a variant of FuzzyART by using the gamma_normalization option.</p><p>GammaNormalizedFuzzyART is a variant of FuzzyART, using the <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a> options. This constructor passes <code>gamma_normalization=true</code>, which internally uses <code>match=:gamma_match</code> and <code>activation=:gamma_activation</code> in addition to the keyword argument options you provide.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs</code>: keyword arguments of FuzzyART options (see <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a>)</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">GammaNormalizedFuzzyART(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/variants.jl#L26"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/variants.jl:26</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/variants.jl#LL18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.artscene_filter-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat" href="#AdaptiveResonance.artscene_filter-Union{Tuple{Array{T, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>AdaptiveResonance.artscene_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">artscene_filter(
    raw_image::Array{T&lt;:AbstractFloat, 3}
) -&gt; Tuple{Array{Float64, 4}, Array{Float64, 3}}
</code></pre><p><strong>Summary</strong></p><p>Process the full artscene filter toolchain on an image.</p><p><strong>Arguments</strong></p><ul><li><code>raw_image::Array{Real, 3}</code>: the raw RGB image to process with the ARTSCENE filter.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">artscene_filter(raw_image)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/ARTSCENE.jl#L294"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/ARTSCENE.jl:294</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/ARTSCENE.jl#LL288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.classify-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.classify-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.classify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classify(
    art::ARTModule,
    x::AbstractMatrix{T} where T&lt;:Real;
    preprocessed,
    get_bmu
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Predict categories of &#39;x&#39; using the ART model.</p><p>Returns predicted categories &#39;y_hat.&#39;</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: ART or ARTMAP module to use for batch inference.</li><li><code>x::RealMatrix</code>: the 2-D dataset containing columns of samples with rows of features.</li><li><code>preprocessed::Bool=false</code>: flag, if the data has already been complement coded or not.</li><li><code>get_bmu::Bool=false</code>, flag, if the model should return the best-matching-unit label in the case of total mismatch.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_DDVFA = DDVFA()
DDVFA
    opts: opts_DDVFA
    ...
julia&gt; x, y = load_data()
julia&gt; train!(my_DDVFA, x)
julia&gt; y_hat = classify(my_DDVFA, y)</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">classify(art, x; preprocessed, get_bmu)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L578"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:578</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.classify-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.classify-Tuple{ARTModule, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.classify</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Predict categories of a single sample of features &#39;x&#39; using the ART model.</p><p>Returns predicted category &#39;y_hat.&#39;</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: ART or ARTMAP module to use for batch inference.</li><li><code>x::RealVector</code>: the single sample of features to classify.</li><li><code>preprocessed::Bool=false</code>: optional, flag if the data has already been complement coded or not.</li><li><code>get_bmu::Bool=false</code>: optional, flag if the model should return the best-matching-unit label in the case of total mismatch.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">classify(art, x; preprocessed, get_bmu)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DDVFA.jl#L319"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:319</code></a>.</p><pre><code class="language-julia hljs">classify(art, x; preprocessed, get_bmu)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DVFA.jl#L326"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:326</code></a>.</p><pre><code class="language-julia hljs">classify(art, x; preprocessed, get_bmu)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/FuzzyART.jl#L341"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:341</code></a>.</p><pre><code class="language-julia hljs">classify(art, x; preprocessed, get_bmu)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/SFAM.jl#L264"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:264</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.complement_code-Tuple{AbstractArray{T} where T&lt;:Real}" href="#AdaptiveResonance.complement_code-Tuple{AbstractArray{T} where T&lt;:Real}"><code>AdaptiveResonance.complement_code</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complement_code(
    data::AbstractArray{T} where T&lt;:Real;
    config
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Normalizes the data x to [0, 1] and returns the augmented vector [x, 1 - x].</p><p><strong>Arguments</strong></p><ul><li><code>data::RealArray</code>: the 1-D or 2-D data to be complement coded.</li><li><code>config::DataConfig=DataConfig()</code>: the data configuration for the ART/ARTMAP module.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">complement_code(data; config)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L428"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:428</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.data_setup!-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.data_setup!-Tuple{ARTModule, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.data_setup!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data_setup!(
    art::ARTModule,
    data::AbstractMatrix{T} where T&lt;:Real
) -&gt; Vector
</code></pre><p><strong>Summary</strong></p><p>Convenience method for setting up the DataConfig of an ART module in advance.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTModule</code>: the ART/ARTMAP module to manually configure the data config for.</li><li><code>data::RealArray</code>: the 2-D batch of data used to create the data config.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">data_setup!(art, data)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L325"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:325</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.data_setup!-Tuple{DataConfig, AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.data_setup!-Tuple{DataConfig, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.data_setup!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data_setup!(
    config::DataConfig,
    data::AbstractMatrix{T} where T&lt;:Real
) -&gt; Vector
</code></pre><p><strong>Summary</strong></p><p>Sets up the data config for the ART module before training.</p><p>This function crucially gets the original and complement-coded dimensions of the data, and it infers the bounds of the data (minimums and maximums) by the largest and smallest values along each feature dimension.</p><p><strong>Arguments</strong></p><ul><li><code>config::DataConfig</code>: the ART/ARTMAP module&#39;s data configuration object.</li><li><code>data::RealMatrix</code>: the 2-D batch of data to use for creating the data configuration.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">data_setup!(config, data)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L302"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:302</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_W-Tuple{DDVFA}" href="#AdaptiveResonance.get_W-Tuple{DDVFA}"><code>AdaptiveResonance.get_W</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_W(art::DDVFA) -&gt; Vector
</code></pre><p><strong>Summary</strong></p><p>Convenience function; return a concatenated array of all DDVFA weights.</p><p><strong>Arguments</strong></p><ul><li><code>art::DDVFA</code>: the DDVFA module to get all of the weights from as a list.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_W(art)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DDVFA.jl#L546"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:546</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DDVFA.jl#LL540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.get_data_characteristics-Tuple{AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.get_data_characteristics-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.get_data_characteristics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data_characteristics(
    data::AbstractMatrix{T} where T&lt;:Real;
    config
) -&gt; NTuple{4, Any}
</code></pre><p><strong>Summary</strong></p><p>Get the characteristics of the data, taking account if a data config is passed.</p><p>If no DataConfig is passed, then the data characteristics come from the array itself. Otherwise, use the config for the statistics of the data and the data array for the number of samples.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealMatrix</code>: the 2-D data to be complement coded.</li><li><code>config::DataConfig=DataConfig()</code>: the data configuration for the ART/ARTMAP module.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">get_data_characteristics(data; config)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L340"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:340</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.linear_normalization-Tuple{AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.linear_normalization-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.linear_normalization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_normalization(
    data::AbstractMatrix{T} where T&lt;:Real;
    config
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Normalize the data to the range [0, 1] along each feature.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealMatrix</code>: the 2-D batch of data to normalize.</li><li><code>config::DataConfig=DataConfig()</code>: the data configuration from the ART/ARTMAP module.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">linear_normalization(data; config)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L395"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:395</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.linear_normalization-Tuple{AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.linear_normalization-Tuple{AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.linear_normalization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_normalization(
    data::AbstractVector{T} where T&lt;:Real;
    config
) -&gt; Vector{Float64}
</code></pre><p><strong>Summary</strong></p><p>Normalize the data to the range [0, 1] along each feature.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealVector</code>: the 1-D sample of data to normalize.</li><li><code>config::DataConfig=DataConfig()</code>: the data configuration from the ART/ARTMAP module.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">linear_normalization(data; config)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L365"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:365</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_DAM-Tuple{}" href="#AdaptiveResonance.opts_DAM-Tuple{}"><code>AdaptiveResonance.opts_DAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opts_DAM(; kwargs...) -&gt; opts_SFAM
</code></pre><p><strong>Summary</strong></p><p>Implements a Default ARTMAP module&#39;s options.</p><p>Default ARTMAP is a variant of SFAM, using the <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a> options. This constructor sets the activation to <code>:choice_by_difference</code> in addition to the keyword argument options you provide.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">opts_DAM(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/variants.jl#L52"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/variants.jl:52</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/variants.jl#LL45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_GammaNormalizedFuzzyART-Tuple{}" href="#AdaptiveResonance.opts_GammaNormalizedFuzzyART-Tuple{}"><code>AdaptiveResonance.opts_GammaNormalizedFuzzyART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opts_GammaNormalizedFuzzyART(; kwargs...)
</code></pre><p><strong>Summary</strong></p><p>Implements a Gamma-Normalized FuzzyART module&#39;s options.</p><p>GammaNormalizedFuzzyART is a variant of FuzzyART, using the <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a> options. This constructor passes <code>gamma_normalization=true</code>, which internally uses <code>match=:gamma_match</code> and <code>activation=:gamma_activation</code> in addition to the keyword argument options you provide.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">opts_GammaNormalizedFuzzyART(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/variants.jl#L50"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/variants.jl:50</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/variants.jl#LL43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.performance-Tuple{AbstractVector{T} where T&lt;:Integer, AbstractVector{T} where T&lt;:Integer}" href="#AdaptiveResonance.performance-Tuple{AbstractVector{T} where T&lt;:Integer, AbstractVector{T} where T&lt;:Integer}"><code>AdaptiveResonance.performance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">performance(
    y_hat::AbstractVector{T} where T&lt;:Integer,
    y::AbstractVector{T} where T&lt;:Integer
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Convenience function to get the categorization performance of y_hat against y.</p><p><strong>Arguments</strong></p><ul><li><code>y_hat::IntegerVector</code>: the estimated labels.</li><li><code>y::IntegerVector</code>: the true labels.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">performance(y_hat, y)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L234"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:234</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.train!" href="#AdaptiveResonance.train!"><code>AdaptiveResonance.train!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">train!(
    art::ARTMAP,
    x::AbstractMatrix{T} where T&lt;:Real,
    y::AbstractVector{T} where T&lt;:Integer
) -&gt; Any
train!(
    art::ARTMAP,
    x::AbstractMatrix{T} where T&lt;:Real,
    y::AbstractVector{T} where T&lt;:Integer,
    preprocessed::Bool
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><pre><code class="nohighlight hljs">train!(art::ARTMAP, x::RealMatrix, y::IntegerVector, preprocessed::Bool=false)</code></pre><p>Train the ARTMAP model on a batch of data &#39;x&#39; with supervisory labels &#39;y.&#39;</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTMAP</code>: the supervised ARTMAP model to train.</li><li><code>x::RealMatrix</code>: the 2-D dataset containing columns of samples with rows of features.</li><li><code>y::IntegerVector</code>: labels for supervisory training.</li><li><code>preprocessed::Bool=false</code>: flag, if the data has already been complement coded or not.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">train!(art, x, y)
train!(art, x, y, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/common.jl#L23"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/common.jl:23</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/common.jl#LL12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.train!-Tuple{ART, AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.train!-Tuple{ART, AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.train!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">train!(
    art::ART,
    x::AbstractMatrix{T} where T&lt;:Real;
    y,
    preprocessed
) -&gt; Any
</code></pre><p><strong>Summary</strong></p><p>Train the ART model on a batch of data &#39;x&#39; with optional supervisory labels &#39;y.&#39;</p><p><strong>Arguments</strong></p><ul><li><code>art::ART</code>: the unsupervised ART model to train.</li><li><code>x::RealMatrix</code>: the 2-D dataset containing columns of samples with rows of features.</li><li><code>y::IntegerVector=Vector{Int}()</code>: optional, labels for simple supervisory training.</li><li><code>preprocessed::Bool=false</code>: optional, flag if the data has already been complement coded or not.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">train!(art, x; y, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/common.jl#L21"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/common.jl:21</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/common.jl#LL12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.train!-Tuple{ART, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.train!-Tuple{ART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.train!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Train the ART model on a single sample of features &#39;x&#39; with an optional supervisory label.</p><p><strong>Arguments</strong></p><ul><li><code>art::ART</code>: the unsupervised ART model to train.</li><li><code>x::RealVector</code>: the single sample feature vector to train upon.</li><li><code>y::Integer=0</code>: optional, a label for simple supervisory training.</li><li><code>preprocessed::Bool=false</code>: optional, flag if the data has already been complement coded or not.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">train!(art, x; y, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DDVFA.jl#L252"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:252</code></a>.</p><pre><code class="language-julia hljs">train!(art, x; y, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DVFA.jl#L254"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:254</code></a>.</p><pre><code class="language-julia hljs">train!(art, x; y, preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/FuzzyART.jl#L279"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:279</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/common.jl#LL66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.train!-Tuple{ARTMAP, AbstractVector{T} where T&lt;:Real, Integer}" href="#AdaptiveResonance.train!-Tuple{ARTMAP, AbstractVector{T} where T&lt;:Real, Integer}"><code>AdaptiveResonance.train!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Summary</strong></p><p>Train the supervised ARTMAP model on a single sample of features &#39;x&#39; with supervisory label &#39;y&#39;.</p><p><strong>Arguments</strong></p><ul><li><code>art::ARTMAP</code>: the supervised ART model to train.</li><li><code>x::RealVector</code>: the single sample feature vector to train upon.</li><li><code>y::Integer</code>: the label for supervisory training.</li><li><code>preprocessed::Bool=false</code>: optional, flag if the data has already been complement coded or not.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">train!(art, x, y; preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/SFAM.jl#L207"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:207</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/common.jl#LL64">source</a></section></article><h3 id="index-types-docs"><a class="docs-heading-anchor" href="#index-types-docs">Types</a><a id="index-types-docs-1"></a><a class="docs-heading-anchor-permalink" href="#index-types-docs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ART" href="#AdaptiveResonance.ART"><code>AdaptiveResonance.ART</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ART &lt;: ARTModule</code></pre><p><strong>Summary</strong></p><p>Abstract supertype for all default unsupervised ART modules.</p><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTMAP" href="#AdaptiveResonance.ARTMAP"><code>AdaptiveResonance.ARTMAP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ARTMAP &lt;: ARTModule</code></pre><p><strong>Summary</strong></p><p>Abstract supertype for all supervised ARTMAP modules.</p><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTModule" href="#AdaptiveResonance.ARTModule"><code>AdaptiveResonance.ARTModule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ARTModule</code></pre><p><strong>Summary</strong></p><p>Abstract supertype for both ART (unsupervised) and ARTMAP (supervised) modules.</p><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTOpts" href="#AdaptiveResonance.ARTOpts"><code>AdaptiveResonance.ARTOpts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ARTOpts</code></pre><p><strong>Summary</strong></p><p>Abstract supertype for all ART module options.</p><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DDVFA" href="#AdaptiveResonance.DDVFA"><code>AdaptiveResonance.DDVFA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DDVFA &lt;: ART</code></pre><p><strong>Summary</strong></p><p>Distributed Dual Vigilance Fuzzy ARTMAP module struct.</p><p>For module options, see <a href="#AdaptiveResonance.opts_DDVFA"><code>AdaptiveResonance.opts_DDVFA</code></a>.</p><p><strong>References</strong></p><ol><li>L. E. Brito da Silva, I. Elnabarawy, and D. C. Wunsch, &#39;Distributed dual vigilance fuzzy adaptive resonance theory learns online, retrieves arbitrarily-shaped clusters, and mitigates order dependence,&#39; Neural Networks, vol. 121, pp. 208-228, 2020, doi: 10.1016/j.neunet.2019.08.033.</li><li>G. Carpenter, S. Grossberg, and D. Rosen, &#39;Fuzzy ART: Fast stable learning and categorization of analog patterns by an adaptive resonance system,&#39; Neural Networks, vol. 4, no. 6, pp. 759-771, 1991.</li></ol><p><strong>Fields</strong></p><ul><li><code>opts::opts_DDVFA</code>: DDVFA options struct.</li></ul><ul><li><code>subopts::opts_FuzzyART</code>: FuzzyART options struct used for all F2 nodes.</li></ul><ul><li><code>config::DataConfig</code>: Data configuration struct.</li></ul><ul><li><code>threshold::Float64</code>: Operating module threshold value, a function of the vigilance parameter.</li></ul><ul><li><code>F2::Vector{FuzzyART}</code>: List of F2 nodes (themselves FuzzyART modules).</li></ul><ul><li><code>labels::Vector{Int64}</code>: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.</li></ul><ul><li><code>n_categories::Int64</code>: Number of total categories.</li></ul><ul><li><code>epoch::Int64</code>: Current training epoch.</li></ul><ul><li><code>T::Float64</code>: Winning activation value from most recent sample.</li></ul><ul><li><code>M::Float64</code>: Winning match value from most recent sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DDVFA.jl#LL95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DDVFA-Tuple{opts_DDVFA}" href="#AdaptiveResonance.DDVFA-Tuple{opts_DDVFA}"><code>AdaptiveResonance.DDVFA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DDVFA(opts::opts_DDVFA) -&gt; DDVFA
</code></pre><p><strong>Summary</strong></p><p>Implements a DDVFA learner with specified options.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_DDVFA</code>: the DDVFA options (see <a href="#AdaptiveResonance.opts_DDVFA"><code>AdaptiveResonance.opts_DDVFA</code></a>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_opts = opts_DDVFA()
julia&gt; DDVFA(my_opts)
DDVFA
    opts: opts_DDVFA
    subopts: opts_FuzzyART
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DDVFA(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DDVFA.jl#L208"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:208</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DDVFA.jl#LL192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DDVFA-Tuple{}" href="#AdaptiveResonance.DDVFA-Tuple{}"><code>AdaptiveResonance.DDVFA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DDVFA(; kwargs...) -&gt; DDVFA
</code></pre><p><strong>Summary</strong></p><p>Implements a DDVFA learner with optional keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs</code>: keyword arguments to pass to the DDVFA options struct (see <a href="#AdaptiveResonance.opts_DDVFA"><code>AdaptiveResonance.opts_DDVFA</code></a>.)</li></ul><p><strong>Examples</strong></p><p>By default:</p><pre><code class="language-julia-repl hljs">julia&gt; DDVFA()
DDVFA
    opts: opts_DDVFA
    subopts: opts_FuzzyART
    ...</code></pre><p>or with keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; DDVFA(rho_lb=0.4, rho_ub = 0.75)
DDVFA
    opts: opts_DDVFA
    subopts: opts_FuzzyART
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DDVFA(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DDVFA.jl#L187"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DDVFA.jl:187</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DDVFA.jl#LL162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DVFA" href="#AdaptiveResonance.DVFA"><code>AdaptiveResonance.DVFA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DVFA &lt;: ART</code></pre><p><strong>Summary</strong></p><p>Dual Vigilance Fuzzy ARTMAP module struct.</p><p>For module options, see <a href="#AdaptiveResonance.opts_DVFA"><code>AdaptiveResonance.opts_DVFA</code></a>.</p><p><strong>References:</strong></p><ol><li>L. E. Brito da Silva, I. Elnabarawy and D. C. Wunsch II, &#39;Dual Vigilance Fuzzy ART,&#39; Neural Networks Letters. To appear.</li><li>G. Carpenter, S. Grossberg, and D. Rosen, &#39;Fuzzy ART: Fast stable learning and categorization of analog patterns by an adaptive resonance system,&#39; Neural Networks, vol. 4, no. 6, pp. 759-771, 1991.</li></ol><p><strong>Fields</strong></p><ul><li><code>opts::opts_DVFA</code>: DVFA options struct.</li></ul><ul><li><code>config::DataConfig</code>: Data configuration struct.</li></ul><ul><li><code>threshold_ub::Float64</code>: Operating upper bound module threshold value, a function of the upper bound vigilance parameter.</li></ul><ul><li><code>threshold_lb::Float64</code>: Operating lower bound module threshold value, a function of the lower bound vigilance parameter.</li></ul><ul><li><code>labels::Vector{Int64}</code>: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.</li></ul><ul><li><code>W::ElasticArrays.ElasticMatrix{Float64, V} where V&lt;:DenseVector{Float64}</code>: Category weight matrix.</li></ul><ul><li><code>T::Vector{Float64}</code>: Activation values for every weight for a given sample.</li></ul><ul><li><code>M::Vector{Float64}</code>: Match values for every weight for a given sample.</li></ul><ul><li><code>n_categories::Int64</code>: Number of category weights (F2 nodes).</li></ul><ul><li><code>n_clusters::Int64</code>: Number of labeled clusters, may be lower than <code>n_categories</code></li></ul><ul><li><code>epoch::Int64</code>: Current training epoch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DVFA.jl#LL61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DVFA-Tuple{opts_DVFA}" href="#AdaptiveResonance.DVFA-Tuple{opts_DVFA}"><code>AdaptiveResonance.DVFA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DVFA(opts::opts_DVFA) -&gt; DVFA
</code></pre><p><strong>Summary</strong></p><p>Implements a DVFA learner with specified options.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_DVFA</code>: the DVFA options (see <a href="#AdaptiveResonance.opts_DVFA"><code>AdaptiveResonance.opts_DVFA</code></a>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_opts = opts_DVFA()
julia&gt; DVFA(my_opts)
DVFA
    opts: opts_DVFA
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DVFA(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DVFA.jl#L176"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:176</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DVFA.jl#LL161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DVFA-Tuple{}" href="#AdaptiveResonance.DVFA-Tuple{}"><code>AdaptiveResonance.DVFA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DVFA(; kwargs...) -&gt; DVFA
</code></pre><p><strong>Summary</strong></p><p>Implements a DVFA learner with optional keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs</code>: keyword arguments to pass to the DVFA options struct (see <a href="#AdaptiveResonance.opts_DVFA"><code>AdaptiveResonance.opts_DVFA</code></a>.)</li></ul><p><strong>Examples</strong></p><p>By default:</p><pre><code class="language-julia-repl hljs">julia&gt; DVFA()
DVFA
    opts: opts_DVFA
    ...</code></pre><p>or with keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; DVFA(rho=0.7)
DVFA
    opts: opts_DVFA
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DVFA(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/DVFA.jl#L156"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/DVFA.jl:156</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DVFA.jl#LL133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DataConfig" href="#AdaptiveResonance.DataConfig"><code>AdaptiveResonance.DataConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DataConfig</code></pre><p><strong>Summary</strong></p><p>Container to standardize training/testing data configuration.</p><p>This container declares if a data configuration has been setup, what the original and complement coded dimensions are, and what the minimums and maximums of the values along each feature dimension are.</p><p><strong>Fields</strong></p><ul><li><code>setup::Bool</code>: Flag if data has been setup yet or not.</li></ul><ul><li><code>mins::Vector{Float64}</code>: List of minimum values for each feature.</li></ul><ul><li><code>maxs::Vector{Float64}</code>: List of maximum values for each feature.</li></ul><ul><li><code>dim::Int64</code>: Dimensionality of the feature vectors (i.e., number of features).</li></ul><ul><li><code>dim_comp::Int64</code>: Complement coded feature dimensionality, twice the size of <code>dim</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DataConfig-Tuple{AbstractMatrix{T} where T&lt;:Real}" href="#AdaptiveResonance.DataConfig-Tuple{AbstractMatrix{T} where T&lt;:Real}"><code>AdaptiveResonance.DataConfig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataConfig(
    data::AbstractMatrix{T} where T&lt;:Real
) -&gt; DataConfig
</code></pre><p><strong>Summary</strong></p><p>Convenience constructor for DataConfig, requiring only the data matrix.</p><p><strong>Arguments</strong></p><ul><li><code>data::RealMatrix</code>: the 2-D batch of data to be used for inferring the data configuration.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DataConfig(data)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L200"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:200</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DataConfig-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.DataConfig-Tuple{AbstractVector{T} where T&lt;:Real, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.DataConfig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataConfig(
    mins::AbstractVector{T} where T&lt;:Real,
    maxs::AbstractVector{T} where T&lt;:Real
) -&gt; DataConfig
</code></pre><p><strong>Summary</strong></p><p>Convenience constructor for DataConfig, requiring only mins and maxs of the features.</p><p>This constructor is used when the mins and maxs differ across features. The dimension is inferred by the length of the mins and maxs.</p><p><strong>Arguments</strong></p><ul><li><code>mins::RealVector</code>: a vector of minimum values for each feature dimension.</li><li><code>maxs::RealVector</code>: a vector of maximum values for each feature dimension.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DataConfig(mins, maxs)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L159"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:159</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DataConfig-Tuple{Real, Real, Integer}" href="#AdaptiveResonance.DataConfig-Tuple{Real, Real, Integer}"><code>AdaptiveResonance.DataConfig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataConfig(min::Real, max::Real, dim::Integer) -&gt; DataConfig
</code></pre><p><strong>Summary</strong></p><p>Convenience constructor for DataConfig, requiring only a global min, max, and dim.</p><p>This constructor is used in the case that the feature mins and maxs are all the same respectively.</p><p><strong>Arguments</strong></p><ul><li><code>min::Real</code>: the minimum value across all features.</li><li><code>max::Real</code>: the maximum value across all features.</li><li><code>dim::Integer</code>: the dimension of the features, which must be provided because it cannot be inferred from just the minimum or maximum values.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DataConfig(min, max, dim)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L184"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:184</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DataConfig-Tuple{}" href="#AdaptiveResonance.DataConfig-Tuple{}"><code>AdaptiveResonance.DataConfig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataConfig() -&gt; DataConfig
</code></pre><p><strong>Summary</strong></p><p>Default constructor for a data configuration, not set up.</p><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">DataConfig()</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/common.jl#L140"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/common.jl:140</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FAM" href="#AdaptiveResonance.FAM"><code>AdaptiveResonance.FAM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FAM &lt;: ARTMAP</code></pre><p><strong>Summary</strong></p><p>Fuzzy ARTMAP struct.</p><p>For module options, see <a href="#AdaptiveResonance.opts_FAM"><code>AdaptiveResonance.opts_FAM</code></a>.</p><p><strong>References</strong></p><ol><li>G. A. Carpenter, S. Grossberg, N. Markuzon, J. H. Reynolds, and D. B. Rosen, “Fuzzy ARTMAP: A Neural Network Architecture for Incremental Supervised Learning of Analog Multidimensional Maps,” IEEE Trans. Neural Networks, vol. 3, no. 5, pp. 698-713, 1992, doi: 10.1109/72.159059.</li></ol><p><strong>Fields</strong></p><ul><li><code>opts::opts_FAM</code>: Fuzzy ARTMAP options struct.</li></ul><ul><li><code>config::DataConfig</code>: Data configuration struct.</li></ul><ul><li><code>W::ElasticArrays.ElasticMatrix{Float64, V} where V&lt;:DenseVector{Float64}</code>: Category weight matrix.</li></ul><ul><li><code>labels::Vector{Int64}</code>: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.</li></ul><ul><li><code>n_categories::Int64</code>: Number of category weights (F2 nodes).</li></ul><ul><li><code>epoch::Int64</code>: Current training epoch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/FAM.jl#LL61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FAM-Tuple{opts_FAM}" href="#AdaptiveResonance.FAM-Tuple{opts_FAM}"><code>AdaptiveResonance.FAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FAM(opts::opts_FAM) -&gt; FAM
</code></pre><p><strong>Summary</strong></p><p>Implements a Fuzzy ARTMAP learner with specified options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; opts = opts_FAM()
julia&gt; FAM(opts)
FAM
    opts: opts_FAM
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">FAM(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/FAM.jl#L142"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/FAM.jl:142</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/FAM.jl#LL130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FAM-Tuple{}" href="#AdaptiveResonance.FAM-Tuple{}"><code>AdaptiveResonance.FAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FAM(; kwargs...) -&gt; FAM
</code></pre><p><strong>Summary</strong></p><p>Implements a Fuzzy ARTMAP learner with optional keyword arguments.</p><p><strong>Examples</strong></p><p>By default:</p><pre><code class="language-julia-repl hljs">julia&gt; FAM()
FAM
    opts: opts_FAM
    ...</code></pre><p>or with keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; FAM(rho=0.7)
FAM
    opts: opts_FAM
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">FAM(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/FAM.jl#L125"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/FAM.jl:125</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/FAM.jl#LL105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FuzzyART" href="#AdaptiveResonance.FuzzyART"><code>AdaptiveResonance.FuzzyART</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FuzzyART &lt;: ART</code></pre><p><strong>Summary</strong></p><p>Gamma-Normalized Fuzzy ART learner struct</p><p>For module options, see <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a>.</p><p><strong>References</strong></p><ol><li>G. Carpenter, S. Grossberg, and D. Rosen, &#39;Fuzzy ART: Fast stable learning and categorization of analog patterns by an adaptive resonance system,&#39; Neural Networks, vol. 4, no. 6, pp. 759-771, 1991.</li></ol><p><strong>Fields</strong></p><ul><li><code>opts::opts_FuzzyART</code>: FuzzyART options struct.</li></ul><ul><li><code>config::DataConfig</code>: Data configuration struct.</li></ul><ul><li><code>threshold::Float64</code>: Operating module threshold value, a function of the vigilance parameter.</li></ul><ul><li><code>labels::Vector{Int64}</code>: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.</li></ul><ul><li><code>T::Vector{Float64}</code>: Activation values for every weight for a given sample.</li></ul><ul><li><code>M::Vector{Float64}</code>: Match values for every weight for a given sample.</li></ul><ul><li><code>W::ElasticArrays.ElasticMatrix{Float64, V} where V&lt;:DenseVector{Float64}</code>: Category weight matrix.</li></ul><ul><li><code>n_instance::Vector{Int64}</code>: Number of weights associated with each category.</li></ul><ul><li><code>n_categories::Int64</code>: Number of category weights (F2 nodes).</li></ul><ul><li><code>epoch::Int64</code>: Current training epoch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/FuzzyART.jl#LL84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FuzzyART-Tuple{opts_FuzzyART, AbstractVector{T} where T&lt;:Real}" href="#AdaptiveResonance.FuzzyART-Tuple{opts_FuzzyART, AbstractVector{T} where T&lt;:Real}"><code>AdaptiveResonance.FuzzyART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FuzzyART(
    opts::opts_FuzzyART,
    sample::AbstractVector{T} where T&lt;:Real;
    preprocessed
) -&gt; FuzzyART
</code></pre><p><strong>Summary</strong></p><p>Create and initialize a FuzzyART with a single sample in one step.</p><p>Principally used as a method for initialization within DDVFA.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_FuzzyART</code>: the FuzzyART options contains.</li><li><code>sample::RealVector</code>: the sample to use as a basis for setting up the FuzzyART.</li><li><code>preprocessed::Bool=false</code>: flag for if the sample is already complement coded and normalized.</li></ul><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">FuzzyART(opts, sample; preprocessed)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/FuzzyART.jl#L221"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:221</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/FuzzyART.jl#LL211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FuzzyART-Tuple{opts_FuzzyART}" href="#AdaptiveResonance.FuzzyART-Tuple{opts_FuzzyART}"><code>AdaptiveResonance.FuzzyART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FuzzyART(opts::opts_FuzzyART) -&gt; FuzzyART
</code></pre><p><strong>Summary</strong></p><p>Implements a Fuzzy ART learner with specified options.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_FuzzyART</code>: the FuzzyART options struct with specified options (see <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FuzzyART(opts)
FuzzyART
    opts: opts_FuzzyART
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">FuzzyART(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/FuzzyART.jl#L190"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:190</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/FuzzyART.jl#LL176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.FuzzyART-Tuple{}" href="#AdaptiveResonance.FuzzyART-Tuple{}"><code>AdaptiveResonance.FuzzyART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FuzzyART(; kwargs...) -&gt; FuzzyART
</code></pre><p><strong>Summary</strong></p><p>Implements a Fuzzy ART learner with optional keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs</code>: keyword arguments of FuzzyART options (see <a href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a>).</li></ul><p><strong>Examples</strong></p><p>By default:</p><pre><code class="language-julia-repl hljs">julia&gt; FuzzyART()
FuzzyART
    opts: opts_FuzzyART
    ...</code></pre><p>or with keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; FuzzyART(rho=0.7)
FuzzyART
    opts: opts_FuzzyART
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">FuzzyART(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ART/FuzzyART.jl#L171"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ART/FuzzyART.jl:171</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/FuzzyART.jl#LL148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.SFAM" href="#AdaptiveResonance.SFAM"><code>AdaptiveResonance.SFAM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SFAM &lt;: ARTMAP</code></pre><p><strong>Summary</strong></p><p>Simple Fuzzy ARTMAP struct.</p><p>For module options, see <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a>.</p><p><strong>References</strong></p><ol><li>G. A. Carpenter, S. Grossberg, N. Markuzon, J. H. Reynolds, and D. B. Rosen, “Fuzzy ARTMAP: A Neural Network Architecture for Incremental Supervised Learning of Analog Multidimensional Maps,” IEEE Trans. Neural Networks, vol. 3, no. 5, pp. 698-713, 1992, doi: 10.1109/72.159059.</li></ol><p><strong>Fields</strong></p><ul><li><code>opts::opts_SFAM</code>: Simplified Fuzzy ARTMAP options struct.</li></ul><ul><li><code>config::DataConfig</code>: Data configuration struct.</li></ul><ul><li><code>W::ElasticArrays.ElasticMatrix{Float64, V} where V&lt;:DenseVector{Float64}</code>: Category weight matrix.</li></ul><ul><li><code>labels::Vector{Int64}</code>: Incremental list of labels corresponding to each F2 node, self-prescribed or supervised.</li></ul><ul><li><code>n_categories::Int64</code>: Number of category weights (F2 nodes).</li></ul><ul><li><code>epoch::Int64</code>: Current training epoch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/SFAM.jl#LL74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.SFAM-Tuple{opts_SFAM}" href="#AdaptiveResonance.SFAM-Tuple{opts_SFAM}"><code>AdaptiveResonance.SFAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SFAM(opts::opts_SFAM) -&gt; SFAM
</code></pre><p><strong>Summary</strong></p><p>Implements a Simple Fuzzy ARTMAP learner with specified options.</p><p><strong>Arguments</strong></p><ul><li><code>opts::opts_SFAM</code>: the Simple Fuzzy ARTMAP options (see <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; opts = opts_SFAM()
julia&gt; SFAM(opts)
SFAM
    opts: opts_SFAM
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">SFAM(opts)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/SFAM.jl#L161"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:161</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/SFAM.jl#LL146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.SFAM-Tuple{}" href="#AdaptiveResonance.SFAM-Tuple{}"><code>AdaptiveResonance.SFAM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SFAM(; kwargs...) -&gt; SFAM
</code></pre><p><strong>Summary</strong></p><p>Implements a Simple Fuzzy ARTMAP learner with optional keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>kwargs</code>: keyword arguments to pass to the Simple Fuzzy ARTMAP options struct (see <a href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a>.)</li></ul><p><strong>Examples</strong></p><p>By default:</p><pre><code class="language-julia-repl hljs">julia&gt; SFAM()
SFAM
    opts: opts_SFAM
    ...</code></pre><p>or with keyword arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; SFAM(rho=0.6)
SFAM
    opts: opts_SFAM
    ...</code></pre><p><strong>Method List / Definition Locations</strong></p><pre><code class="language-julia hljs">SFAM(; kwargs...)</code></pre><p>defined at <a href="https://github.com/AP6YC/AdaptiveResonance.jl/tree/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c//src/ARTMAP/SFAM.jl#L141"><code>/home/runner/work/AdaptiveResonance.jl/AdaptiveResonance.jl/src/ARTMAP/SFAM.jl:141</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/SFAM.jl#LL118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_DDVFA" href="#AdaptiveResonance.opts_DDVFA"><code>AdaptiveResonance.opts_DDVFA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct opts_DDVFA &lt;: ARTOpts</code></pre><p><strong>Summary</strong></p><p>Distributed Dual Vigilance Fuzzy ART options struct.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Fields</strong></p><ul><li><p><code>rho_lb::Float64</code>: Lower-bound vigilance parameter: rho_lb ∈ [0, 1].  Default: 0.7</p></li><li><p><code>rho_ub::Float64</code>: Upper bound vigilance parameter: rho_ub ∈ [0, 1].  Default: 0.85</p></li><li><p><code>alpha::Float64</code>: Choice parameter: alpha &gt; 0.  Default: 0.001</p></li><li><p><code>beta::Float64</code>: Learning parameter: beta ∈ (0, 1].  Default: 1.0</p></li><li><p><code>gamma::Float64</code>: Pseudo kernel width: gamma &gt;= 1.  Default: 3.0</p></li><li><p><code>gamma_ref::Float64</code>: Reference gamma for normalization: 0 &lt;= gamma_ref &lt; gamma.  Default: 1.0</p></li><li><p><code>similarity::Symbol</code>: Similarity method (activation and match): similarity ∈ [:single, :average, :complete, :median, :weighted, :centroid].  Default: :single</p></li><li><p><code>max_epoch::Int64</code>: Maximum number of epochs during training: max_epochs ∈ (1, Inf).  Default: 1</p></li><li><p><code>display::Bool</code>: Display flag for progress bars.  Default: false</p></li><li><p><code>gamma_normalization::Bool</code>: Flag to normalize the threshold by the feature dimension.  Default: true</p></li><li><p><code>uncommitted::Bool</code>: Flag to use an uncommitted node when learning.</p><p>If true, new weights are created with ones(dim) and learn on the complement-coded sample. If false, fast-committing is used where the new weight is simply the complement-coded sample.  Default: false</p></li><li><p><code>match::Symbol</code>: Selected match function.  Default: :gamma_match</p></li><li><p><code>activation::Symbol</code>: Selected activation function.  Default: :gamma_activation</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DDVFA.jl#LL16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_DVFA" href="#AdaptiveResonance.opts_DVFA"><code>AdaptiveResonance.opts_DVFA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct opts_DVFA &lt;: ARTOpts</code></pre><p><strong>Summary</strong></p><p>Dual Vigilance Fuzzy ART options struct.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Fields</strong></p><ul><li><p><code>rho_lb::Float64</code>: Lower-bound vigilance parameter: rho_lb ∈ [0, 1].  Default: 0.55</p></li><li><p><code>rho_ub::Float64</code>: Upper bound vigilance parameter: rho_ub ∈ [0, 1].  Default: 0.75</p></li><li><p><code>alpha::Float64</code>: Choice parameter: alpha &gt; 0.  Default: 0.001</p></li><li><p><code>beta::Float64</code>: Learning parameter: beta ∈ (0, 1].  Default: 1.0</p></li><li><p><code>max_epochs::Int64</code>: Maximum number of epochs during training.  Default: 1</p></li><li><p><code>display::Bool</code>: Display flag for progress bars.  Default: false</p></li><li><p><code>uncommitted::Bool</code>: Flag to use an uncommitted node when learning.</p><p>If true, new weights are created with ones(dim) and learn on the complement-coded sample. If false, fast-committing is used where the new weight is simply the complement-coded sample.  Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DVFA.jl#LL16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_FAM" href="#AdaptiveResonance.opts_FAM"><code>AdaptiveResonance.opts_FAM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct opts_FAM &lt;: ARTOpts</code></pre><p><strong>Summary</strong></p><p>Implements a Fuzzy ARTMAP learner&#39;s options.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Fields</strong></p><ul><li><p><code>rho::Float64</code>: Vigilance parameter: rho ∈ [0, 1].  Default: 0.6</p></li><li><p><code>alpha::Float64</code>: Choice parameter: alpha &gt; 0.  Default: 1.0e-7</p></li><li><p><code>epsilon::Float64</code>: Match tracking parameter: epsilon ∈ (0, 1).  Default: 0.001</p></li><li><p><code>beta::Float64</code>: Learning parameter: beta ∈ (0, 1].  Default: 1.0</p></li><li><p><code>max_epochs::Int64</code>: Maximum number of epochs during training: max_epochs ∈ [1, Inf)  Default: 1</p></li><li><p><code>uncommitted::Bool</code>: Uncommitted node flag.  Default: true</p></li><li><p><code>display::Bool</code>: Display flag for progress bars.  Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/FAM.jl#LL15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_FuzzyART" href="#AdaptiveResonance.opts_FuzzyART"><code>AdaptiveResonance.opts_FuzzyART</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct opts_FuzzyART &lt;: ARTOpts</code></pre><p><strong>Summary</strong></p><p>Gamma-Normalized Fuzzy ART options struct.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Fields</strong></p><ul><li><p><code>rho::Float64</code>: Vigilance parameter: rho ∈ [0, 1].  Default: 0.6</p></li><li><p><code>alpha::Float64</code>: Choice parameter: alpha &gt; 0.  Default: 0.001</p></li><li><p><code>beta::Float64</code>: Learning parameter: beta ∈ (0, 1].  Default: 1.0</p></li><li><p><code>gamma::Float64</code>: Pseudo kernel width: gamma &gt;= 1.  Default: 3.0</p></li><li><p><code>gamma_ref::Float64</code>: Reference gamma for normalization: 0 &lt;= gamma_ref &lt; gamma.  Default: 1.0</p></li><li><p><code>max_epochs::Int64</code>: Maximum number of epochs during training: max_epochs ∈ (1, Inf).  Default: 1</p></li><li><p><code>display::Bool</code>: Display flag for progress bars.  Default: false</p></li><li><p><code>gamma_normalization::Bool</code>: Flag to normalize the threshold by the feature dimension.  Default: false</p></li><li><p><code>uncommitted::Bool</code>: Flag to use an uncommitted node when learning.</p><p>If true, new weights are created with ones(dim) and learn on the complement-coded sample. If false, fast-committing is used where the new weight is simply the complement-coded sample.  Default: false</p></li><li><p><code>match::Symbol</code>: Selected match function.  Default: :basic_match</p></li><li><p><code>activation::Symbol</code>: Selected activation function.  Default: :basic_activation</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/FuzzyART.jl#LL15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.opts_SFAM" href="#AdaptiveResonance.opts_SFAM"><code>AdaptiveResonance.opts_SFAM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct opts_SFAM &lt;: ARTOpts</code></pre><p><strong>Summary</strong></p><p>Implements a Simple Fuzzy ARTMAP learner&#39;s options.</p><p>These options are a <a href="https://github.com/mauro3/Parameters.jl"><code>Parameters.jl</code></a> struct, taking custom options keyword arguments. Each field has a default value listed below.</p><p><strong>Fields</strong></p><ul><li><p><code>rho::Float64</code>: Vigilance parameter: rho ∈ [0, 1].  Default: 0.75</p></li><li><p><code>alpha::Float64</code>: Choice parameter: alpha &gt; 0.  Default: 1.0e-7</p></li><li><p><code>epsilon::Float64</code>: Match tracking parameter: epsilon ∈ (0, 1).  Default: 0.001</p></li><li><p><code>beta::Float64</code>: Learning parameter: beta ∈ (0, 1].  Default: 1.0</p></li><li><p><code>max_epochs::Int64</code>: Maximum number of epochs during training: max_epochs ∈ [1, Inf).  Default: 1</p></li><li><p><code>display::Bool</code>: Display flag for progress bars.  Default: false</p></li><li><p><code>uncommitted::Bool</code>: Flag to use an uncommitted node when learning.</p><p>If true, new weights are created with ones(dim) and learn on the complement-coded sample. If false, fast-committing is used where the new weight is simply the complement-coded sample.  Default: false</p></li><li><p><code>match::Symbol</code>: Selected match function.  Default: :basic_match</p></li><li><p><code>activation::Symbol</code>: Selected activation function.  Default: :basic_activation</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/SFAM.jl#LL15-L18">source</a></section></article><h3 id="index-constants-docs"><a class="docs-heading-anchor" href="#index-constants-docs">Constants</a><a id="index-constants-docs-1"></a><a class="docs-heading-anchor-permalink" href="#index-constants-docs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ACTIVATION_FUNCTIONS" href="#AdaptiveResonance.ACTIVATION_FUNCTIONS"><code>AdaptiveResonance.ACTIVATION_FUNCTIONS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ACTIVATION_FUNCTIONS</p><p><strong>Description</strong></p><p>Enumerates all of the activation functions available in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL743">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ADAPTIVERESONANCE_MODULES" href="#AdaptiveResonance.ADAPTIVERESONANCE_MODULES"><code>AdaptiveResonance.ADAPTIVERESONANCE_MODULES</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ADAPTIVERESONANCE_MODULES</p><p><strong>Description</strong></p><p>A combined list of all unsupervised ART and supervised ARTMAP modules from the <code>AdaptiveResonance.jl</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/AdaptiveResonance.jl#LL121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ADAPTIVERESONANCE_VERSION" href="#AdaptiveResonance.ADAPTIVERESONANCE_VERSION"><code>AdaptiveResonance.ADAPTIVERESONANCE_VERSION</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ADAPTIVERESONANCE_VERSION</p><p><strong>Description</strong></p><p>A constant that contains the version of the installed AdaptiveResonance.jl package.</p><p>This value is computed at compile time, so it may be used to programmatically verify the version of <code>AdaptiveResonance</code> that is installed in case a <code>compat</code> entry in your Project.toml is missing or otherwise incorrect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/version.jl#LL24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ARTMAP_MODULES" href="#AdaptiveResonance.ARTMAP_MODULES"><code>AdaptiveResonance.ARTMAP_MODULES</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ARTMAP_MODULES</p><p><strong>Description</strong></p><p>A list of supervised ARTMAP modules that are available in the <code>AdaptiveResonance.jl</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ARTMAP/ARTMAP.jl#LL14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.ART_MODULES" href="#AdaptiveResonance.ART_MODULES"><code>AdaptiveResonance.ART_MODULES</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>ART_MODULES</p><p><strong>Description</strong></p><p>A list of (default) unsupervised ART modules that are available in the <code>AdaptiveResonance.jl</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/ART.jl#LL14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.DDVFA_METHODS" href="#AdaptiveResonance.DDVFA_METHODS"><code>AdaptiveResonance.DDVFA_METHODS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>DDVFA_METHODS</p><p><strong>Description</strong></p><p>A list of all DDVFA similarity linkage methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/ART/DDVFA.jl#LL450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveResonance.MATCH_FUNCTIONS" href="#AdaptiveResonance.MATCH_FUNCTIONS"><code>AdaptiveResonance.MATCH_FUNCTIONS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>MATCH_FUNCTIONS</p><p><strong>Description</strong></p><p>Enumerates all of the match functions available in the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AP6YC/AdaptiveResonance.jl/blob/a8bf7ea41fb7fcfd912bc122e96bea9f64b85f0c/src/common.jl#LL735">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributing/">« Contributing</a><a class="docs-footer-nextpage" href="../dev-index/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 15 December 2022 23:22">Thursday 15 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
